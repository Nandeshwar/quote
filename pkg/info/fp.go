// Code generated by 'gofp'. DO NOT EDIT.
package info
import "reflect" 
import "sort" 
import "sync" 
import "time"
import "github.com/logic-building/functional-go/fp" 

func Map(f func(Info) Info, list []Info) []Info {
	if f == nil {
		return []Info{}
	}
	newList := make([]Info, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

func MapPtr(f func(*Info) *Info, list []*Info) []*Info {
	if f == nil {
		return []*Info{}
	}
	newList := make([]*Info, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapPtrErr takes 2 arguments:
//  1. A function input argument: *Info and return types (*Info, error)
//  2. A list of type []*Info
//
// Returns:
// 	([]*Info, error)
func MapPtrErr(f func(*Info) (*Info, error), list []*Info) ([]*Info, error) {
	if f == nil {
		return []*Info{}, nil
	}
	newList := make([]*Info, len(list))
	for i, v := range list {
		var err error
		newList[i], err = f(v)
		if err != nil {
			return nil, err
		}
	}
	return newList, nil
}

// MapErr takes 2 arguments:
//  1. A function input argument: Info and return types (Info, error)
//  2. A list of type []Info
//
// Returns:
// 	([]Info, error)
func MapErr(f func(Info) (Info, error), list []Info) ([]Info, error) {
	if f == nil {
		return []Info{}, nil
	}
	newList := make([]Info, len(list))
	for i, v := range list {
		var err error
		newList[i], err = f(v)
		if err != nil {
			return nil, err
		}
	}
	return newList, nil
}

func Filter(f func(Info) bool, list []Info) []Info {
	if f == nil {
		return []Info{}
	}
	var newList []Info
	for _, v := range list {
		if f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

func FilterPtr(f func(*Info) bool, list []*Info) []*Info {
	if f == nil {
		return []*Info{}
	}
	var newList []*Info
	for _, v := range list {
		if f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

// FilterPtrErr takes two arguments
//  1. Function: takes 1 argument of type Info and returns (bool, error)
//  2. slice of type []*Info
//
// Returns:
//  new filtered list and error
func FilterPtrErr(f func(*Info) (bool, error), list []*Info) ([]*Info, error) {
	if f == nil {
		return []*Info{}, nil
	}
	var newList []*Info
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

// FilterErr takes two arguments
//  1. Function: takes 1 argument of type Info and returns (bool, error)
//  2. slice of type []Info
//
// Returns:
//  new filtered list and error
func FilterErr(f func(Info) (bool, error), list []Info) ([]Info, error) {
	if f == nil {
		return []Info{}, nil
	}
	var newList []Info
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

func Remove(f func(Info) bool, list []Info) []Info {
	if f == nil {
		return []Info{}
	}
	var newList []Info
	for _, v := range list {
		if !f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

func RemovePtr(f func(*Info) bool, list []*Info) []*Info {
	if f == nil {
		return []*Info{}
	}
	var newList []*Info
	for _, v := range list {
		if !f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

// RemovePtrErr removes the items from the given list based on supplied function and returns new list
//
// Takes 2 inputs:
//	1. Function: input type *Info and return types(bool, error)
//	2. List of type: []*Info
//
// Returns:
//	New list and error: ([]*Info, error)
//	Empty list if both of arguments are nil or either one is nil.
func RemovePtrErr(f func(*Info) (bool, error), list []*Info) ([]*Info, error) {
	if f == nil {
		return []*Info{}, nil
	}
	var newList []*Info
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

// RemoveErr removes the items from the given list based on supplied function and returns new list
//
// Takes 2 inputs:
//	1. Function: input type Info and return types(bool, error)
//	2. List of type: []Info
//
// Returns:
//	New list and error: ([]Info, error)
//	Empty list if both of arguments are nil or either one is nil.
func RemoveErr(f func(Info) (bool, error), list []Info) ([]Info, error) {
	if f == nil {
		return []Info{}, nil
	}
	var newList []Info
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

func Some(f func(Info) bool, list []Info) bool {
	if f == nil {
		return false
	}
	for _, v := range list {
		if f(v) {
			return true
		}
	}
	return false
}

func SomePtr(f func(*Info) bool, list []*Info) bool {
	if f == nil {
		return false
	}
	for _, v := range list {
		if f(v) {
			return true
		}
	}
	return false
}

// SomePtrErr finds item in the list based on supplied function.
//
// Takes 2 input:
//	1. Function
//	2. List
//
// Returns:
//	(bool,err).
//	True if condition satisfies, else false
func SomePtrErr(f func(*Info) (bool, error), list []*Info) (bool, error) {
	if f == nil {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if r {
			return true, nil
		}
	}
	return false, nil
}

// SomeErr finds item in the list based on supplied function.
//
// Takes 2 input:
//	1. Function
//	2. List
//
// Returns:
//	(bool,err).
//	True if condition satisfies, else false
func SomeErr(f func(Info) (bool, error), list []Info) (bool, error) {
	if f == nil {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if r {
			return true, nil
		}
	}
	return false, nil
}

func Every(f func(Info) bool, list []Info) bool {
	if f == nil || len(list) == 0 {
		return false
	}
	for _, v := range list {
		if !f(v) {
			return false
		}
	}
	return true
}

func EveryPtr(f func(*Info) bool, list []*Info) bool {
	if f == nil || len(list) == 0 {
		return false
	}
	for _, v := range list {
		if !f(v) {
			return false
		}
	}
	return true
}

// EveryPtrErr returns true if supplied function returns logical true for every item in the list
func EveryPtrErr(f func(*Info) (bool, error), list []*Info) (bool, error) {
	if f == nil || len(list) == 0 {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if !r {
			return false, nil
		}
	}
	return true, nil
}

// EveryErr returns true if supplied function returns logical true for every item in the list
func EveryErr(f func(Info) (bool, error), list []Info) (bool, error) {
	if f == nil || len(list) == 0 {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if !r {
			return false, nil
		}
	}
	return true, nil
}

func DropWhile(f func(Info) bool, list []Info) []Info {
	if f == nil {
		return []Info{}
	}
	var newList []Info
	for i, v := range list {
		if !f(v) {
			listLen := len(list)
			newList = make([]Info, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList
		}
	}
	return newList
}

func DropWhilePtr(f func(*Info) bool, list []*Info) []*Info {
	if f == nil {
		return []*Info{}
	}
	var newList []*Info
	for i, v := range list {
		if !f(v) {
			listLen := len(list)
			newList = make([]*Info, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList
		}
	}
	return newList
}

// DropWhilePtrErr drops the items from the list as long as condition satisfies.
//
// Takes two inputs
//	1. Function: takes one input and returns (boolean, error)
//	2. list
//
// Returns:
// 	New List, error
//  Empty list if either one of arguments or both of them are nil
func DropWhilePtrErr(f func(*Info) (bool, error), list []*Info) ([]*Info, error) {
	if f == nil {
		return []*Info{}, nil
	}
	var newList []*Info
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			listLen := len(list)
			newList = make([]*Info, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList, nil
		}
	}
	return newList, nil
}

// DropWhileErr drops the items from the list as long as condition satisfies.
//
// Takes two inputs
//	1. Function: takes one input and returns (boolean, error)
//	2. list
//
// Returns:
// 	New List, error
//  Empty list if either one of arguments or both of them are nil
func DropWhileErr(f func(Info) (bool, error), list []Info) ([]Info, error) {
	if f == nil {
		return []Info{}, nil
	}
	var newList []Info
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			listLen := len(list)
			newList = make([]Info, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList, nil
		}
	}
	return newList, nil
}

func TakeWhile(f func(Info) bool, list []Info) []Info {
	if f == nil {
		return []Info{}
	}
	var newList []Info
	for _, v := range list {
		if !f(v) {
			return newList
		}
		newList = append(newList, v)
	}
	return newList
}

func TakeWhilePtr(f func(*Info) bool, list []*Info) []*Info {
	if f == nil {
		return []*Info{}
	}
	var newList []*Info
	for _, v := range list {
		if !f(v) {
			return newList
		}
		newList = append(newList, v)
	}
	return newList
}

// TakeWhilePtrErr returns new list based on condition in the supplied function. It returns new list once condition fails.
//
// Takes 2 inputs:
//	1. Function - 1 input of type *Info and returns ([]*Info, error)
//	2. List
//
// Returns:
//	New List, error.
//	Empty list if all the parameters are nil or either of one parameter is nil
func TakeWhilePtrErr(f func(*Info) (bool, error), list []*Info) ([]*Info, error) {
	if f == nil {
		return []*Info{}, nil
	}
	var newList []*Info
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			return newList, nil
		}
		newList = append(newList, v)
	}
	return newList, nil
}

// TakeWhileErr returns new list based on condition in the supplied function. It returns new list once condition fails.
//
// Takes 2 inputs:
//	1. Function - 1 input of type Info and returns ([]Info, error)
//	2. List
//
// Returns:
//	New List, error.
//	Empty list if all the parameters are nil or either of one parameter is nil
func TakeWhileErr(f func(Info) (bool, error), list []Info) ([]Info, error) {
	if f == nil {
		return []Info{}, nil
	}
	var newList []Info
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			return newList, nil
		}
		newList = append(newList, v)
	}
	return newList, nil
}

// PMap applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMap(f func(Info) Info, list []Info, optional ...fp.Optional) []Info {
	if f == nil {
		return []Info{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapNoOrder(f, list, worker)
		}
	}

	return pMapPreserveOrder(f, list, worker)
}

func pMapPreserveOrder(f func(Info) Info, list []Info, worker int) []Info {
	chJobs := make(chan map[int]Info, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]Info{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]Info, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]Info, chJobs chan map[int]Info) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]Info{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]Info, len(list))
	newList := make([]Info, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapNoOrder(f func(Info) Info, list []Info, worker int) []Info {
	chJobs := make(chan Info, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan Info, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan Info, chJobs chan Info) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]Info, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapPtr applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapPtr(f func(*Info) *Info, list []*Info, optional ...fp.Optional) []*Info {
	if f == nil {
		return []*Info{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapPtrNoOrder(f, list, worker)
		}
	}

	return pMapPtrPreserveOrder(f, list, worker)
}

func pMapPtrPreserveOrder(f func(*Info) *Info, list []*Info, worker int) []*Info {
	chJobs := make(chan map[int]*Info, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*Info{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*Info, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*Info, chJobs chan map[int]*Info) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]*Info{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*Info, len(list))
	newList := make([]*Info, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapPtrNoOrder(f func(*Info) *Info, list []*Info, worker int) []*Info {
	chJobs := make(chan *Info, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *Info, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *Info, chJobs chan *Info) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*Info, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapPtrErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapPtrErr(f func(*Info) (*Info, error), list []*Info, optional ...fp.Optional) ([]*Info, error) {
	if f == nil {
		return []*Info{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapPtrErrNoOrder(f, list, worker)
		}
	}

	return pMapPtrErrPreserveOrder(f, list, worker)
}

func pMapPtrErrPreserveOrder(f func(*Info) (*Info, error), list []*Info, worker int) ([]*Info, error) {
	chJobs := make(chan map[int]*Info, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*Info{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*Info, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*Info, chJobs chan map[int]*Info, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]*Info{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*Info, len(list))
	newList := make([]*Info, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []*Info{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []*Info{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapPtrErrNoOrder(f func(*Info) (*Info, error), list []*Info, worker int) ([]*Info, error) {
	chJobs := make(chan *Info, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *Info, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *Info, chJobs chan *Info, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*Info, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []*Info{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []*Info{}, <-errCh
	}

	return newList, nil
}

// PMapErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapErr(f func(Info) (Info, error), list []Info, optional ...fp.Optional) ([]Info, error) {
	if f == nil {
		return []Info{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapErrNoOrder(f, list, worker)
		}
	}

	return pMapErrPreserveOrder(f, list, worker)
}

func pMapErrPreserveOrder(f func(Info) (Info, error), list []Info, worker int) ([]Info, error) {
	chJobs := make(chan map[int]Info, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]Info{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]Info, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]Info, chJobs chan map[int]Info, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]Info{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]Info, len(list))
	newList := make([]Info, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []Info{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []Info{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapErrNoOrder(f func(Info) (Info, error), list []Info, worker int) ([]Info, error) {
	chJobs := make(chan Info, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan Info, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan Info, chJobs chan Info, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]Info, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []Info{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []Info{}, <-errCh
	}

	return newList, nil
}

func FilterMap(fFilter func(Info) bool, fMap func(Info) Info, list []Info) []Info {
	if fFilter == nil || fMap == nil {
		return []Info{}
	}
	var newList []Info
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

func FilterMapPtr(fFilter func(*Info) bool, fMap func(*Info) *Info, list []*Info) []*Info {
	if fFilter == nil || fMap == nil {
		return []*Info{}
	}
	var newList []*Info
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapPtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input(*Info) and returns (bool, error).
//	2. Function: takes *Info as argument and returns (*Info, error)
// 	3. Slice of type []*Info
//
// Returns:
//	New List ([]*Info, error).
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapPtrErr(fFilter func(*Info) (bool, error), fMap func(*Info) (*Info, error), list []*Info) ([]*Info, error) {
	if fFilter == nil || fMap == nil {
		return []*Info{}, nil
	}
	var newList []*Info
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input(Info) and returns (bool, error).
//	2. Function: takes Info as argument and returns (Info, error)
// 	3. Slice of type []Info
//
// Returns:
//	New List ([]Info, error).
//  Empty list if all there parameters are nil or either of parameter is nil
//
func FilterMapErr(fFilter func(Info) (bool, error), fMap func(Info) (Info, error), list []Info) ([]Info, error) {
	if fFilter == nil || fMap == nil {
		return []Info{}, nil
	}
	var newList []Info
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

func Rest(l []Info) []Info {
	if l == nil {
		return []Info{}
	}

	len := len(l)
	if len == 0 || len == 1 {
		return []Info{}
	}

	newList := make([]Info, len-1)

	for i, v := range l[1:] {
		newList[i] = v
	}

	return newList
}


// Rest removes 1st item of the list and return new list having rest of the items
func RestPtr(l []*Info) []*Info {
	if l == nil {
		return []*Info{}
	}

	len := len(l)
	if len == 0 || len == 1 {
		return []*Info{}
	}

	newList := make([]*Info, len-1)

	for i, v := range l[1:] {
		newList[i] = v
	}

	return newList
}

func Reduce(f func(Info, Info) Info, list []Info, initializer ...Info) Info {
	var init Info 
	lenList := len(list)

	if initializer != nil {
		init = initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0]
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}
	
	if lenList == 0 {
		return init
	}
	r := f(init, list[0])
	return Reduce(f, list[1:], r)
}

func ReducePtr(f func(*Info, *Info) *Info, list []*Info, initializer ...Info) *Info {
	var initVal Info
	var init *Info = &initVal
	lenList := len(list)

	if initializer != nil {
		init = &initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0]
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init
	}

	r := f(init, list[0])
	return ReducePtr(f, list[1:], *r)
}

// ReducePtrErr reduces a list to a single value by combining elements via a supplied function
//
// Takes three inputs
//	A. function - takes two arguments (*Info, *Info)
//	B. list of type []*Info
// 	C. initializer (optional of type Info)
//
// Returns:
//	single value, error: (*Info, error)
func ReducePtrErr(f func(*Info, *Info) (*Info, error), list []*Info, initializer ...Info) (*Info, error) {
	var initVal Info
	var init *Info = &initVal
	lenList := len(list)

	if initializer != nil {
		init = &initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0], nil
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init, nil
	}

	r, err := f(init, list[0])
	if err != nil {
		return nil, err
	}
	return ReducePtrErr(f, list[1:], *r)
}

// ReduceErr reduces a list to a single value by combining elements via a supplied function
//
// Takes three inputs
//	A. function - takes two arguments (Info, Info)
//	B. list of type []Info
// 	C. initializer (optional of type Info)
//
// Returns:
//	single value, error: (Info, error)
func ReduceErr(f func(Info, Info) (Info, error), list []Info, initializer ...Info) (Info, error) {
	var initVal Info
	var init Info = initVal
	lenList := len(list)

	if initializer != nil {
		init = initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0], nil
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init, nil
	}

	r, err := f(init, list[0])
	if err != nil {
		return r, err
	}
	return ReduceErr(f, list[1:], r)
}

// DropLast drops last item from the list and returns new list.
// Returns empty list if there is only one item in the list or list empty
func DropLast(list []Info) []Info {
	listLen := len(list)

	if list == nil || listLen == 0 || listLen == 1 {
		return []Info{}
	}

	newList := make([]Info, listLen-1)

	for i := 0; i < listLen-1; i++ {
		newList[i] = list[i]
	}
	return newList
}

// DropLastPtr drops last item from the list and returns new list.
// Returns empty list if there is only one item in the list or list empty
func DropLastPtr(list []*Info) []*Info {
	listLen := len(list)

	if list == nil || listLen == 0 || listLen == 1 {
		return []*Info{}
	}

	newList := make([]*Info, listLen-1)

	for i := 0; i < listLen-1; i++ {
		newList[i] = list[i]
	}
	return newList
}

// Reverses reverse the list
func Reverses(list []Info) []Info {
	newList := make([]Info, len(list))
	for i := 0; i < len(list); i++ {
		newList[i] = list[len(list)-(i+1)]
	}
	return newList
}

// ReversesPtr reverse the list
func ReversesPtr(list []*Info) []*Info {
	newList := make([]*Info, len(list))
	for i := 0; i < len(list); i++ {
		newList[i] = list[len(list)-(i+1)]
	}
	return newList
}

// Take returns n items in the list
func Take(n int, list []Info) []Info {
	if n < 0 {
		return []Info{}
	}

	newListLen := len(list)

	if n < newListLen {
		newListLen = n
	}
	newList := make([]Info, newListLen)
	for i := 0; i < newListLen; i++ {
		newList[i] = list[i]
	}
	return newList
}

// TakePtr returns n items in the list
func TakePtr(n int, list []*Info) []*Info {
	if n < 0 {
		return []*Info{}
	}

	newListLen := len(list)

	if n < newListLen {
		newListLen = n
	}
	newList := make([]*Info, newListLen)
	for i := 0; i < newListLen; i++ {
		newList[i] = list[i]
	}
	return newList
}

// DistinctP returns true if no two of the arguments are =
func DistinctP(list []Info) bool {
	if len(list) == 0 {
		return false
	}

	for i := 0; i < len(list); i++ {
		for j := i + 1; j < len(list); j++ {
			if reflect.DeepEqual(list[i], list[j]) {
				return false
			}
		}
	}
	return true
}

// DistinctPPtr returns true if no two of the arguments are =
func DistinctPPtr(list []*Info) bool {
	if len(list) == 0 {
		return false
	}

	for i := 0; i < len(list); i++ {
		for j := i + 1; j < len(list); j++ {
			if reflect.DeepEqual(*list[i], *list[j]) {
				return false
			}
		}
	}
	return true
}

// Distinct removes duplicates.
func Distinct(list []Info) []Info {
	if len(list) == 0 {
		return []Info{}
	}

	newList := []Info{list[0]}

	for i := 1; i < len(list); i++ {
		found := false
		for j := 0; j < len(newList); j++ {
			if reflect.DeepEqual(list[i], newList[j]) {
				found = true
				break
			}
		}
		if !found {
			newList = append(newList, list[i])
		}
	}
	return newList
}

func DistinctPtr(list []*Info) []*Info {
	if len(list) == 0 {
		return []*Info{}
	}

	newList := []*Info{list[0]}

	for i := 1; i < len(list); i++ {
		found := false
		for j := 0; j < len(newList); j++ {
			if reflect.DeepEqual(*list[i], *newList[j]) {
				found = true
				break
			}
		}
		if !found {
			newList = append(newList, list[i])
		}
	}
	return newList
}

// Union return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func Union(arrList ...[]Info) []Info {
	var newList []Info

	for _, arr := range arrList {
		for _, v := range arr {
			found := false
			for i := 0; i < len(newList); i++ {
				if reflect.DeepEqual(newList[i], v) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, v)
			}
		}
	}
	return newList
}

// UnionPtr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionPtr(arrList ...[]*Info) []*Info {
	var newList []*Info

	for _, arr := range arrList {
		for _, v := range arr {
			found := false
			for i := 0; i < len(newList); i++ {
				if reflect.DeepEqual(*newList[i], *v) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, v)
			}
		}
	}
	return newList
}

// Intersection return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func Intersection(arrList ...[]Info) []Info {
	if arrList == nil {
		return []Info{}
	}

	var newList []Info

	if len(arrList) == 1 {
		for i := 0; i < len(arrList[0]); i++ {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(newList[j], arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if reflect.DeepEqual(arrList[0][i], v) {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(newList[j], arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
	}
	return newList
}

// IntersectionPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionPtr(arrList ...[]*Info) []*Info {
	if arrList == nil {
		return []*Info{}
	}

	var newList []*Info

	if len(arrList) == 1 {
		for i := 0; i < len(arrList[0]); i++ {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(*newList[j], *arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if reflect.DeepEqual(*arrList[0][i], *v) {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(*newList[j], *arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
	}
	return newList
}

// Difference returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceInfo(arrList ...[]Info) []Info {
	if arrList == nil {
		return []Info{}
	}

	var newList []Info

	if len(arrList) == 1 {
		for i := 0; i < len(arrList[0]); i++ {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(newList[j], arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if reflect.DeepEqual(arrList[0][i], v) {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(newList[j], arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
	}
	return newList
}

// DifferencePtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferencePtr(arrList ...[]*Info) []*Info {
	if arrList == nil {
		return []*Info{}
	}

	var newList []*Info

	if len(arrList) == 1 {
		for i := 0; i < len(arrList[0]); i++ {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(*newList[j], *arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if reflect.DeepEqual(*arrList[0][i], *v) {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(*newList[j], *arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
	}
	return newList
}

// Subset returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored, order does not matter
func Subset(list1, list2 []Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	for i := 0; i < len(list1); i++ {
		found := false
		for j := 0; j < len(list2); j++ {
			if reflect.DeepEqual(list1[i], list2[j]) {
				found = true
			}
		}
		if !found {
			return false
		}
	}
	return true
}

// SubsetPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored, order does not matter
func SubsetPtr(list1, list2 []*Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	for i := 0; i < len(list1); i++ {
		found := false
		for j := 0; j < len(list2); j++ {
			if reflect.DeepEqual(*list1[i], *list2[j]) {
				found = true
			}
		}
		if !found {
			return false
		}
	}
	return true
}

// Superset returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored, order does not matter
func Superset(list1, list2 []Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	for i := 0; i < len(list2); i++ {
		found := false
		for j := 0; j < len(list1); j++ {
			if reflect.DeepEqual(list2[i], list1[j]) {
				found = true
			}
		}
		if !found {
			return false
		}
	}
	return true
}

// SupersetPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored, order does not matter
func SupersetPtr(list1, list2 []*Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	for i := 0; i < len(list2); i++ {
		found := false
		for j := 0; j < len(list1); j++ {
			if reflect.DeepEqual(*list2[i], *list1[j]) {
				found = true
			}
		}
		if !found {
			return false
		}
	}
	return true
}

// Set returns a set of the distinct elements of coll.
func Set(list []Info) []Info {
	if len(list) == 0 {
		return []Info{}
	}

	newList := []Info{list[0]}

	for i := 1; i < len(list); i++ {
		found := false
		for j := 0; j < len(newList); j++ {
			if reflect.DeepEqual(list[i], newList[j]) {
				found = true
				break
			}
		}
		if !found {
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetPtr returns a set of the distinct elements of coll.
func SetPtr(list []*Info) []*Info {
	if len(list) == 0 {
		return []*Info{}
	}

	newList := []*Info{list[0]}

	for i := 1; i < len(list); i++ {
		found := false
		for j := 0; j < len(newList); j++ {
			if reflect.DeepEqual(*list[i], *newList[j]) {
				found = true
				break
			}
		}
		if !found {
			newList = append(newList, list[i])
		}
	}
	return newList
}


// MapInfoStr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapInfoStr(f func(Info) string, list []Info) []string {
	if f == nil {
		return []string{}
	}
	newList := make([]string, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapInfoStrErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list and error
func MapInfoStrErr(f func(Info) (string, error), list []Info) ([]string, error) {
	if f == nil {
		return []string{}, nil
	}
	newList := make([]string, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// MapInfoStrPtr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapInfoStrPtr(f func(*Info) *string, list []*Info) []*string {
	if f == nil {
		return []*string{}
	}
	newList := make([]*string, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapInfoStrPtrErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list, error
func MapInfoStrPtrErr(f func(*Info) (*string, error), list []*Info) ([]*string, error) {
	if f == nil {
		return []*string{}, nil
	}
	newList := make([]*string, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// PMapInfoStr applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapInfoStr(f func(Info) string, list []Info, optional ...fp.Optional) []string {
	if f == nil {
		return []string{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapInfoStrNoOrder(f, list, worker)
		}
	}

	return pMapInfoStrPreserveOrder(f, list, worker)
}

func pMapInfoStrPreserveOrder(f func(Info) string, list []Info, worker int) []string {
	chJobs := make(chan map[int]Info, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]Info{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]string, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]string, chJobs chan map[int]Info) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]string{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]string, len(list))
	newList := make([]string, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapInfoStrNoOrder(f func(Info) string, list []Info, worker int) []string {
	chJobs := make(chan Info, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan string, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan string, chJobs chan Info) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]string, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapInfoStrErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapInfoStrErr(f func(Info) (string, error), list []Info, optional ...fp.Optional) ([]string, error) {
	if f == nil {
		return []string{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapInfoStrErrNoOrder(f, list, worker)
		}
	}

	return pMapInfoStrErrPreserveOrder(f, list, worker)
}

func pMapInfoStrErrPreserveOrder(f func(Info) (string, error), list []Info, worker int) ([]string, error) {
	chJobs := make(chan map[int]Info, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]Info{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]string, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]string, chJobs chan map[int]Info, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]string{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]string, len(list))
	newList := make([]string, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []string{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []string{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapInfoStrErrNoOrder(f func(Info) (string, error), list []Info, worker int) ([]string, error) {
	chJobs := make(chan Info, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan string, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan string, chJobs chan Info, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]string, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []string{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []string{}, <-errCh
	}

	return newList, nil
}

// PMapInfoStrPtr applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapInfoStrPtr(f func(*Info) *string, list []*Info, optional ...fp.Optional) []*string {
	if f == nil {
		return []*string{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapInfoStrPtrNoOrder(f, list, worker)
		}
	}

	return pMapInfoStrPtrPreserveOrder(f, list, worker)
}

func pMapInfoStrPtrPreserveOrder(f func(*Info) *string, list []*Info, worker int) []*string {
	chJobs := make(chan map[int]*Info, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*Info{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*string, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*string, chJobs chan map[int]*Info) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]*string{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*string, len(list))
	newList := make([]*string, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapInfoStrPtrNoOrder(f func(*Info) *string, list []*Info, worker int) []*string {
	chJobs := make(chan *Info, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *string, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *string, chJobs chan *Info) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*string, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapInfoStrPtrErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapInfoStrPtrErr(f func(*Info) (*string, error), list []*Info, optional ...fp.Optional) ([]*string, error) {
	if f == nil {
		return []*string{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapInfoStrPtrErrNoOrder(f, list, worker)
		}
	}

	return pMapInfoStrPtrErrPreserveOrder(f, list, worker)
}

func pMapInfoStrPtrErrPreserveOrder(f func(*Info) (*string, error), list []*Info, worker int) ([]*string, error) {
	chJobs := make(chan map[int]*Info, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*Info{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*string, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*string, chJobs chan map[int]*Info, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]*string{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*string, len(list))
	newList := make([]*string, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []*string{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []*string{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapInfoStrPtrErrNoOrder(f func(*Info) (*string, error), list []*Info, worker int) ([]*string, error) {
	chJobs := make(chan *Info, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *string, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *string, chJobs chan *Info, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*string, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []*string{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []*string{}, <-errCh
	}

	return newList, nil
}

// FilterMapInfoStr filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input type - Info and returns true/false.
//	2. Function: takes Info as argument and returns string
// 	3. List of type Info
//
// Returns:
//	New List of type string
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapInfoStr(fFilter func(Info) bool, fMap func(Info) string, list []Info) []string {
	if fFilter == nil || fMap == nil {
		return []string{}
	}
	var newList []string
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapInfoStrPtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - *Info and returns (bool, error).
//	2. Function: takes *Info as argument and returns (*string, error)
// 	3. List of type *Info
//
// Returns:
//	New List of type *string, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapInfoStrPtrErr(fFilter func(*Info) (bool, error), fMap func(*Info) (*string, error), list []*Info) ([]*string, error) {
	if fFilter == nil || fMap == nil {
		return []*string{}, nil
	}
	var newList []*string
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapInfoStrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - Info and returns (bool, error).
//	2. Function: takes Info as argument and returns (string, error)
// 	3. List of type Info
//
// Returns:
//	New List of type string, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapInfoStrErr(fFilter func(Info) (bool, error), fMap func(Info) (string, error), list []Info) ([]string, error) {
	if fFilter == nil || fMap == nil {
		return []string{}, nil
	}
	var newList []string
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// MapStrInfo takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapStrInfo(f func(string) Info, list []string) []Info {
	if f == nil {
		return []Info{}
	}
	newList := make([]Info, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapStrInfoErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list and error
func MapStrInfoErr(f func(string) (Info, error), list []string) ([]Info, error) {
	if f == nil {
		return []Info{}, nil
	}
	newList := make([]Info, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// MapStrInfoPtr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapStrInfoPtr(f func(*string) *Info, list []*string) []*Info {
	if f == nil {
		return []*Info{}
	}
	newList := make([]*Info, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapStrInfoPtrErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list, error
func MapStrInfoPtrErr(f func(*string) (*Info, error), list []*string) ([]*Info, error) {
	if f == nil {
		return []*Info{}, nil
	}
	newList := make([]*Info, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// PMapStrInfo applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapStrInfo(f func(string) Info, list []string, optional ...fp.Optional) []Info {
	if f == nil {
		return []Info{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapStrInfoNoOrder(f, list, worker)
		}
	}

	return pMapStrInfoPreserveOrder(f, list, worker)
}

func pMapStrInfoPreserveOrder(f func(string) Info, list []string, worker int) []Info {
	chJobs := make(chan map[int]string, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]string{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]Info, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]Info, chJobs chan map[int]string) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]Info{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]Info, len(list))
	newList := make([]Info, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapStrInfoNoOrder(f func(string) Info, list []string, worker int) []Info {
	chJobs := make(chan string, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan Info, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan Info, chJobs chan string) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]Info, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapStrInfoErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapStrInfoErr(f func(string) (Info, error), list []string, optional ...fp.Optional) ([]Info, error) {
	if f == nil {
		return []Info{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapStrInfoErrNoOrder(f, list, worker)
		}
	}

	return pMapStrInfoErrPreserveOrder(f, list, worker)
}

func pMapStrInfoErrPreserveOrder(f func(string) (Info, error), list []string, worker int) ([]Info, error) {
	chJobs := make(chan map[int]string, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]string{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]Info, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]Info, chJobs chan map[int]string, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]Info{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]Info, len(list))
	newList := make([]Info, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []Info{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []Info{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapStrInfoErrNoOrder(f func(string) (Info, error), list []string, worker int) ([]Info, error) {
	chJobs := make(chan string, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan Info, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan Info, chJobs chan string, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]Info, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []Info{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []Info{}, <-errCh
	}

	return newList, nil
}

// PMapStrInfoPtr applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapStrInfoPtr(f func(*string) *Info, list []*string, optional ...fp.Optional) []*Info {
	if f == nil {
		return []*Info{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapStrInfoPtrNoOrder(f, list, worker)
		}
	}

	return pMapStrInfoPtrPreserveOrder(f, list, worker)
}

func pMapStrInfoPtrPreserveOrder(f func(*string) *Info, list []*string, worker int) []*Info {
	chJobs := make(chan map[int]*string, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*string{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*Info, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*Info, chJobs chan map[int]*string) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]*Info{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*Info, len(list))
	newList := make([]*Info, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapStrInfoPtrNoOrder(f func(*string) *Info, list []*string, worker int) []*Info {
	chJobs := make(chan *string, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *Info, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *Info, chJobs chan *string) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*Info, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapStrInfoPtrErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapStrInfoPtrErr(f func(*string) (*Info, error), list []*string, optional ...fp.Optional) ([]*Info, error) {
	if f == nil {
		return []*Info{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapStrInfoPtrErrNoOrder(f, list, worker)
		}
	}

	return pMapStrInfoPtrErrPreserveOrder(f, list, worker)
}

func pMapStrInfoPtrErrPreserveOrder(f func(*string) (*Info, error), list []*string, worker int) ([]*Info, error) {
	chJobs := make(chan map[int]*string, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*string{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*Info, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*Info, chJobs chan map[int]*string, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]*Info{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*Info, len(list))
	newList := make([]*Info, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []*Info{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []*Info{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapStrInfoPtrErrNoOrder(f func(*string) (*Info, error), list []*string, worker int) ([]*Info, error) {
	chJobs := make(chan *string, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *Info, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *Info, chJobs chan *string, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*Info, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []*Info{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []*Info{}, <-errCh
	}

	return newList, nil
}

// FilterMapStrInfo filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input type - string and returns true/false.
//	2. Function: takes string as argument and returns Info
// 	3. List of type string
//
// Returns:
//	New List of type Info
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapStrInfo(fFilter func(string) bool, fMap func(string) Info, list []string) []Info {
	if fFilter == nil || fMap == nil {
		return []Info{}
	}
	var newList []Info
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapStrInfoPtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - *string and returns (bool, error).
//	2. Function: takes *string as argument and returns (*Info, error)
// 	3. List of type *string
//
// Returns:
//	New List of type *Info, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapStrInfoPtrErr(fFilter func(*string) (bool, error), fMap func(*string) (*Info, error), list []*string) ([]*Info, error) {
	if fFilter == nil || fMap == nil {
		return []*Info{}, nil
	}
	var newList []*Info
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapStrInfoErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - string and returns (bool, error).
//	2. Function: takes string as argument and returns (Info, error)
// 	3. List of type string
//
// Returns:
//	New List of type Info, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapStrInfoErr(fFilter func(string) (bool, error), fMap func(string) (Info, error), list []string) ([]Info, error) {
	if fFilter == nil || fMap == nil {
		return []Info{}, nil
	}
	var newList []Info
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}


type byTitleInfo []Info

func (a byTitleInfo) Len() int           { return len(a) }
func (a byTitleInfo) Less(i, j int) bool { return a[i].Title < a[j].Title }
func (a byTitleInfo) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortInfoByTitle sort structs
func SortInfoByTitle(list []Info) []Info {
	if len(list) == 0 {
		return []Info{}
	}
	newList := make([]Info, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byTitleInfo(newList))
	return newList
}

// SortInfoByTitlePtr sorts structs
func SortInfoByTitlePtr(list []*Info) []*Info {
	if len(list) == 0 {
		return []*Info{}
	}
	newList := make([]Info, len(list))
	newListPtr := make([]*Info, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byTitleInfo(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byTitleInfoDesc []Info

func (a byTitleInfoDesc) Len() int           { return len(a) }
func (a byTitleInfoDesc) Less(i, j int) bool { return a[i].Title > a[j].Title }
func (a byTitleInfoDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortInfoByTitleDesc sorts structs
func SortInfoByTitleDesc(list []Info) []Info {
	if len(list) == 0 {
		return []Info{}
	}
	newList := make([]Info, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byTitleInfoDesc(newList))
	return newList
}

// SortInfoByTitleDescPtr sorts structs
func SortInfoByTitleDescPtr(list []*Info) []*Info {
	if len(list) == 0 {
		return []*Info{}
	}
	newList := make([]Info, len(list))
	newListPtr := make([]*Info, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byTitleInfoDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byInfoInfo []Info

func (a byInfoInfo) Len() int           { return len(a) }
func (a byInfoInfo) Less(i, j int) bool { return a[i].Info < a[j].Info }
func (a byInfoInfo) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortInfoByInfo sort structs
func SortInfoByInfo(list []Info) []Info {
	if len(list) == 0 {
		return []Info{}
	}
	newList := make([]Info, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byInfoInfo(newList))
	return newList
}

// SortInfoByInfoPtr sorts structs
func SortInfoByInfoPtr(list []*Info) []*Info {
	if len(list) == 0 {
		return []*Info{}
	}
	newList := make([]Info, len(list))
	newListPtr := make([]*Info, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byInfoInfo(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byInfoInfoDesc []Info

func (a byInfoInfoDesc) Len() int           { return len(a) }
func (a byInfoInfoDesc) Less(i, j int) bool { return a[i].Info > a[j].Info }
func (a byInfoInfoDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortInfoByInfoDesc sorts structs
func SortInfoByInfoDesc(list []Info) []Info {
	if len(list) == 0 {
		return []Info{}
	}
	newList := make([]Info, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byInfoInfoDesc(newList))
	return newList
}

// SortInfoByInfoDescPtr sorts structs
func SortInfoByInfoDescPtr(list []*Info) []*Info {
	if len(list) == 0 {
		return []*Info{}
	}
	newList := make([]Info, len(list))
	newListPtr := make([]*Info, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byInfoInfoDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byCreationDateInfo []Info

func (a byCreationDateInfo) Len() int           { return len(a) }
func (a byCreationDateInfo) Less(i, j int) bool { return a[i].CreationDate.Before(a[j].CreationDate) }
func (a byCreationDateInfo) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortInfoByCreationDate sort structs
func SortInfoByCreationDate(list []Info) []Info {
	if len(list) == 0 {
		return []Info{}
	}
	newList := make([]Info, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byCreationDateInfo(newList))
	return newList
}

// SortInfoByCreationDatePtr sorts structs
func SortInfoByCreationDatePtr(list []*Info) []*Info {
	if len(list) == 0 {
		return []*Info{}
	}
	newList := make([]Info, len(list))
	newListPtr := make([]*Info, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byCreationDateInfo(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byCreationDateInfoDesc []Info

func (a byCreationDateInfoDesc) Len() int           { return len(a) }
func (a byCreationDateInfoDesc) Less(i, j int) bool { return a[i].CreationDate.After(a[j].CreationDate) }
func (a byCreationDateInfoDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortInfoByCreationDateDesc sorts structs
func SortInfoByCreationDateDesc(list []Info) []Info {
	if len(list) == 0 {
		return []Info{}
	}
	newList := make([]Info, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byCreationDateInfoDesc(newList))
	return newList
}

// SortInfoByCreationDateDescPtr sorts structs
func SortInfoByCreationDateDescPtr(list []*Info) []*Info {
	if len(list) == 0 {
		return []*Info{}
	}
	newList := make([]Info, len(list))
	newListPtr := make([]*Info, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byCreationDateInfoDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
// UnionInfoByTitle return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionInfoByTitle(arrList ...[]Info) []Info {
	resultMap := make(map[string]bool)
	var resultArr []Info
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Title]
			if !ok {
				resultMap[v.Title] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionInfoByTitlePtr(arrList ...[]*Info) []*Info {
	resultMap := make(map[string]bool)
	var resultArr []*Info
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Title]
			if !ok {
				resultMap[v.Title] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionInfoByTitle return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionInfoByTitle(arrList ...[]Info) []Info {
	if arrList == nil {
		return []Info{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Title]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Title] = true
			}
		}
		return newList
	}

	var newList []Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Title == v.Title {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Title]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Title] = true
			}
		}
	}
	return newList
}

// IntersectionInfoByTitlePtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionInfoByTitlePtr(arrList ...[]*Info) []*Info {
	if arrList == nil {
		return []*Info{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Title]
			if !ok {
				resultMap[arrList[0][i].Title] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Title == v.Title {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Title]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Title] = true
			}
		}
	}
	return newList
}

// DifferenceInfoByTitle returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceInfoByTitle(arrList ...[]Info) []Info {
	if arrList == nil {
		return []Info{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Title]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Title] = true
			}
		}
		return newList
	}

	var newList []Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Title == v.Title {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Title]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Title] = true
			}
		}
	}
	return newList
}

// DifferenceInfoByTitlePtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceInfoByTitlePtr(arrList ...[]*Info) []*Info {
	if arrList == nil {
		return []*Info{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Title]
			if !ok {
				resultMap[arrList[0][i].Title] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Title == v.Title {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Title]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Title] = true
			}
		}
	}
	return newList
}

// SubsetInfoByTitle returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetInfoByTitle(list1, list2 []Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Title]
		if !ok {
			found := false
			resultMap[list1[i].Title] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Title == list2[j].Title {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetInfoByTitlePtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetInfoByTitlePtr(list1, list2 []*Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Title]
		if !ok {
			found := false
			resultMap[list1[i].Title] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Title == list2[j].Title {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetInfoByTitle returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetInfoByTitle(list1, list2 []Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Title]
		if !ok {
			found := false
			resultMap[list2[i].Title] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Title == list1[j].Title {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetInfoByTitlePtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetInfoByTitlePtr(list1, list2 []*Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Title]
		if !ok {
			found := false
			resultMap[list2[i].Title] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Title == list1[j].Title {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetInfoByTitle returns a set of the distinct elements of coll.
func SetInfoByTitle(list []Info) []Info {
	if list == nil || len(list) == 0 {
		return []Info{}
	}

	resultMap := make(map[string]bool)
	newList := []Info{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Title]
		if !ok {
			resultMap[list[i].Title] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetInfoByTitlePtr returns a set of the distinct elements of coll.
func SetInfoByTitlePtr(list []*Info) []*Info {
	if list == nil || len(list) == 0 {
		return []*Info{}
	}

	resultMap := make(map[string]bool)
	newList := []*Info{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Title]
		if !ok {
			resultMap[list[i].Title] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionInfoByInfo return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionInfoByInfo(arrList ...[]Info) []Info {
	resultMap := make(map[string]bool)
	var resultArr []Info
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Info]
			if !ok {
				resultMap[v.Info] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionInfoByInfoPtr(arrList ...[]*Info) []*Info {
	resultMap := make(map[string]bool)
	var resultArr []*Info
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Info]
			if !ok {
				resultMap[v.Info] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionInfoByInfo return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionInfoByInfo(arrList ...[]Info) []Info {
	if arrList == nil {
		return []Info{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Info]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Info] = true
			}
		}
		return newList
	}

	var newList []Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Info == v.Info {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Info]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Info] = true
			}
		}
	}
	return newList
}

// IntersectionInfoByInfoPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionInfoByInfoPtr(arrList ...[]*Info) []*Info {
	if arrList == nil {
		return []*Info{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Info]
			if !ok {
				resultMap[arrList[0][i].Info] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Info == v.Info {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Info]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Info] = true
			}
		}
	}
	return newList
}

// DifferenceInfoByInfo returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceInfoByInfo(arrList ...[]Info) []Info {
	if arrList == nil {
		return []Info{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Info]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Info] = true
			}
		}
		return newList
	}

	var newList []Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Info == v.Info {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Info]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Info] = true
			}
		}
	}
	return newList
}

// DifferenceInfoByInfoPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceInfoByInfoPtr(arrList ...[]*Info) []*Info {
	if arrList == nil {
		return []*Info{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Info]
			if !ok {
				resultMap[arrList[0][i].Info] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Info == v.Info {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Info]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Info] = true
			}
		}
	}
	return newList
}

// SubsetInfoByInfo returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetInfoByInfo(list1, list2 []Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Info]
		if !ok {
			found := false
			resultMap[list1[i].Info] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Info == list2[j].Info {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetInfoByInfoPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetInfoByInfoPtr(list1, list2 []*Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Info]
		if !ok {
			found := false
			resultMap[list1[i].Info] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Info == list2[j].Info {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetInfoByInfo returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetInfoByInfo(list1, list2 []Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Info]
		if !ok {
			found := false
			resultMap[list2[i].Info] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Info == list1[j].Info {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetInfoByInfoPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetInfoByInfoPtr(list1, list2 []*Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Info]
		if !ok {
			found := false
			resultMap[list2[i].Info] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Info == list1[j].Info {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetInfoByInfo returns a set of the distinct elements of coll.
func SetInfoByInfo(list []Info) []Info {
	if list == nil || len(list) == 0 {
		return []Info{}
	}

	resultMap := make(map[string]bool)
	newList := []Info{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Info]
		if !ok {
			resultMap[list[i].Info] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetInfoByInfoPtr returns a set of the distinct elements of coll.
func SetInfoByInfoPtr(list []*Info) []*Info {
	if list == nil || len(list) == 0 {
		return []*Info{}
	}

	resultMap := make(map[string]bool)
	newList := []*Info{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Info]
		if !ok {
			resultMap[list[i].Info] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionInfoByCreationDate return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionInfoByCreationDate(arrList ...[]Info) []Info {
	resultMap := make(map[time.Time]bool)
	var resultArr []Info
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.CreationDate]
			if !ok {
				resultMap[v.CreationDate] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionInfoByCreationDatePtr(arrList ...[]*Info) []*Info {
	resultMap := make(map[time.Time]bool)
	var resultArr []*Info
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.CreationDate]
			if !ok {
				resultMap[v.CreationDate] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionInfoByCreationDate return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionInfoByCreationDate(arrList ...[]Info) []Info {
	if arrList == nil {
		return []Info{}
	}

	resultMap := make(map[time.Time]bool)
	if len(arrList) == 1 {
		var newList []Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].CreationDate]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].CreationDate] = true
			}
		}
		return newList
	}

	var newList []Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].CreationDate == v.CreationDate {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].CreationDate]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].CreationDate] = true
			}
		}
	}
	return newList
}

// IntersectionInfoByCreationDatePtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionInfoByCreationDatePtr(arrList ...[]*Info) []*Info {
	if arrList == nil {
		return []*Info{}
	}

	resultMap := make(map[time.Time]bool)
	if len(arrList) == 1 {
		var newList []*Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].CreationDate]
			if !ok {
				resultMap[arrList[0][i].CreationDate] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].CreationDate == v.CreationDate {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].CreationDate]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].CreationDate] = true
			}
		}
	}
	return newList
}

// DifferenceInfoByCreationDate returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceInfoByCreationDate(arrList ...[]Info) []Info {
	if arrList == nil {
		return []Info{}
	}

	resultMap := make(map[time.Time]bool)
	if len(arrList) == 1 {
		var newList []Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].CreationDate]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].CreationDate] = true
			}
		}
		return newList
	}

	var newList []Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].CreationDate == v.CreationDate {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].CreationDate]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].CreationDate] = true
			}
		}
	}
	return newList
}

// DifferenceInfoByCreationDatePtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceInfoByCreationDatePtr(arrList ...[]*Info) []*Info {
	if arrList == nil {
		return []*Info{}
	}

	resultMap := make(map[time.Time]bool)
	if len(arrList) == 1 {
		var newList []*Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].CreationDate]
			if !ok {
				resultMap[arrList[0][i].CreationDate] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].CreationDate == v.CreationDate {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].CreationDate]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].CreationDate] = true
			}
		}
	}
	return newList
}

// SubsetInfoByCreationDate returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetInfoByCreationDate(list1, list2 []Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[time.Time]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].CreationDate]
		if !ok {
			found := false
			resultMap[list1[i].CreationDate] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].CreationDate == list2[j].CreationDate {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetInfoByCreationDatePtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetInfoByCreationDatePtr(list1, list2 []*Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[time.Time]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].CreationDate]
		if !ok {
			found := false
			resultMap[list1[i].CreationDate] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].CreationDate == list2[j].CreationDate {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetInfoByCreationDate returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetInfoByCreationDate(list1, list2 []Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[time.Time]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].CreationDate]
		if !ok {
			found := false
			resultMap[list2[i].CreationDate] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].CreationDate == list1[j].CreationDate {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetInfoByCreationDatePtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetInfoByCreationDatePtr(list1, list2 []*Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[time.Time]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].CreationDate]
		if !ok {
			found := false
			resultMap[list2[i].CreationDate] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].CreationDate == list1[j].CreationDate {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetInfoByCreationDate returns a set of the distinct elements of coll.
func SetInfoByCreationDate(list []Info) []Info {
	if list == nil || len(list) == 0 {
		return []Info{}
	}

	resultMap := make(map[time.Time]bool)
	newList := []Info{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].CreationDate]
		if !ok {
			resultMap[list[i].CreationDate] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetInfoByCreationDatePtr returns a set of the distinct elements of coll.
func SetInfoByCreationDatePtr(list []*Info) []*Info {
	if list == nil || len(list) == 0 {
		return []*Info{}
	}

	resultMap := make(map[time.Time]bool)
	newList := []*Info{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].CreationDate]
		if !ok {
			resultMap[list[i].CreationDate] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}