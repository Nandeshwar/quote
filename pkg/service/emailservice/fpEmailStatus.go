// Code generated by 'gofp'. DO NOT EDIT.
package emailservice
import _ "reflect" 
import "sort" 
import "sync" 
import "time"
import "github.com/logic-building/functional-go/fp" 

func MapEmailStatus(f func(EmailStatus) EmailStatus, list []EmailStatus) []EmailStatus {
	if f == nil {
		return []EmailStatus{}
	}
	newList := make([]EmailStatus, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

func MapEmailStatusPtr(f func(*EmailStatus) *EmailStatus, list []*EmailStatus) []*EmailStatus {
	if f == nil {
		return []*EmailStatus{}
	}
	newList := make([]*EmailStatus, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapEmailStatusPtrErr takes 2 arguments:
//  1. A function input argument: *EmailStatus and return types (*EmailStatus, error)
//  2. A list of type []*EmailStatus
//
// Returns:
// 	([]*EmailStatus, error)
func MapEmailStatusPtrErr(f func(*EmailStatus) (*EmailStatus, error), list []*EmailStatus) ([]*EmailStatus, error) {
	if f == nil {
		return []*EmailStatus{}, nil
	}
	newList := make([]*EmailStatus, len(list))
	for i, v := range list {
		var err error
		newList[i], err = f(v)
		if err != nil {
			return nil, err
		}
	}
	return newList, nil
}

// MapEmailStatusErr takes 2 arguments:
//  1. A function input argument: EmailStatus and return types (EmailStatus, error)
//  2. A list of type []EmailStatus
//
// Returns:
// 	([]EmailStatus, error)
func MapEmailStatusErr(f func(EmailStatus) (EmailStatus, error), list []EmailStatus) ([]EmailStatus, error) {
	if f == nil {
		return []EmailStatus{}, nil
	}
	newList := make([]EmailStatus, len(list))
	for i, v := range list {
		var err error
		newList[i], err = f(v)
		if err != nil {
			return nil, err
		}
	}
	return newList, nil
}

func FilterEmailStatus(f func(EmailStatus) bool, list []EmailStatus) []EmailStatus {
	if f == nil {
		return []EmailStatus{}
	}
	var newList []EmailStatus
	for _, v := range list {
		if f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

func FilterEmailStatusPtr(f func(*EmailStatus) bool, list []*EmailStatus) []*EmailStatus {
	if f == nil {
		return []*EmailStatus{}
	}
	var newList []*EmailStatus
	for _, v := range list {
		if f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

// FilterEmailStatusPtrErr takes two arguments
//  1. Function: takes 1 argument of type EmailStatus and returns (bool, error)
//  2. slice of type []*EmailStatus
//
// Returns:
//  new filtered list and error
func FilterEmailStatusPtrErr(f func(*EmailStatus) (bool, error), list []*EmailStatus) ([]*EmailStatus, error) {
	if f == nil {
		return []*EmailStatus{}, nil
	}
	var newList []*EmailStatus
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

// FilterEmailStatusErr takes two arguments
//  1. Function: takes 1 argument of type EmailStatus and returns (bool, error)
//  2. slice of type []EmailStatus
//
// Returns:
//  new filtered list and error
func FilterEmailStatusErr(f func(EmailStatus) (bool, error), list []EmailStatus) ([]EmailStatus, error) {
	if f == nil {
		return []EmailStatus{}, nil
	}
	var newList []EmailStatus
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

func RemoveEmailStatus(f func(EmailStatus) bool, list []EmailStatus) []EmailStatus {
	if f == nil {
		return []EmailStatus{}
	}
	var newList []EmailStatus
	for _, v := range list {
		if !f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

func RemoveEmailStatusPtr(f func(*EmailStatus) bool, list []*EmailStatus) []*EmailStatus {
	if f == nil {
		return []*EmailStatus{}
	}
	var newList []*EmailStatus
	for _, v := range list {
		if !f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

// RemoveEmailStatusPtrErr removes the items from the given list based on supplied function and returns new list
//
// Takes 2 inputs:
//	1. Function: input type *EmailStatus and return types(bool, error)
//	2. List of type: []*EmailStatus
//
// Returns:
//	New list and error: ([]*EmailStatus, error)
//	Empty list if both of arguments are nil or either one is nil.
func RemoveEmailStatusPtrErr(f func(*EmailStatus) (bool, error), list []*EmailStatus) ([]*EmailStatus, error) {
	if f == nil {
		return []*EmailStatus{}, nil
	}
	var newList []*EmailStatus
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

// RemoveEmailStatusErr removes the items from the given list based on supplied function and returns new list
//
// Takes 2 inputs:
//	1. Function: input type EmailStatus and return types(bool, error)
//	2. List of type: []EmailStatus
//
// Returns:
//	New list and error: ([]EmailStatus, error)
//	Empty list if both of arguments are nil or either one is nil.
func RemoveEmailStatusErr(f func(EmailStatus) (bool, error), list []EmailStatus) ([]EmailStatus, error) {
	if f == nil {
		return []EmailStatus{}, nil
	}
	var newList []EmailStatus
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

func SomeEmailStatus(f func(EmailStatus) bool, list []EmailStatus) bool {
	if f == nil {
		return false
	}
	for _, v := range list {
		if f(v) {
			return true
		}
	}
	return false
}

func SomeEmailStatusPtr(f func(*EmailStatus) bool, list []*EmailStatus) bool {
	if f == nil {
		return false
	}
	for _, v := range list {
		if f(v) {
			return true
		}
	}
	return false
}

// SomeEmailStatusPtrErr finds item in the list based on supplied function.
//
// Takes 2 input:
//	1. Function
//	2. List
//
// Returns:
//	(bool,err).
//	True if condition satisfies, else false
func SomeEmailStatusPtrErr(f func(*EmailStatus) (bool, error), list []*EmailStatus) (bool, error) {
	if f == nil {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if r {
			return true, nil
		}
	}
	return false, nil
}

// SomeEmailStatusErr finds item in the list based on supplied function.
//
// Takes 2 input:
//	1. Function
//	2. List
//
// Returns:
//	(bool,err).
//	True if condition satisfies, else false
func SomeEmailStatusErr(f func(EmailStatus) (bool, error), list []EmailStatus) (bool, error) {
	if f == nil {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if r {
			return true, nil
		}
	}
	return false, nil
}

func EveryEmailStatus(f func(EmailStatus) bool, list []EmailStatus) bool {
	if f == nil || len(list) == 0 {
		return false
	}
	for _, v := range list {
		if !f(v) {
			return false
		}
	}
	return true
}

func EveryEmailStatusPtr(f func(*EmailStatus) bool, list []*EmailStatus) bool {
	if f == nil || len(list) == 0 {
		return false
	}
	for _, v := range list {
		if !f(v) {
			return false
		}
	}
	return true
}

// EveryEmailStatusPtrErr returns true if supplied function returns logical true for every item in the list
func EveryEmailStatusPtrErr(f func(*EmailStatus) (bool, error), list []*EmailStatus) (bool, error) {
	if f == nil || len(list) == 0 {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if !r {
			return false, nil
		}
	}
	return true, nil
}

// EveryEmailStatusErr returns true if supplied function returns logical true for every item in the list
func EveryEmailStatusErr(f func(EmailStatus) (bool, error), list []EmailStatus) (bool, error) {
	if f == nil || len(list) == 0 {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if !r {
			return false, nil
		}
	}
	return true, nil
}

func DropWhileEmailStatus(f func(EmailStatus) bool, list []EmailStatus) []EmailStatus {
	if f == nil {
		return []EmailStatus{}
	}
	var newList []EmailStatus
	for i, v := range list {
		if !f(v) {
			listLen := len(list)
			newList = make([]EmailStatus, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList
		}
	}
	return newList
}

func DropWhileEmailStatusPtr(f func(*EmailStatus) bool, list []*EmailStatus) []*EmailStatus {
	if f == nil {
		return []*EmailStatus{}
	}
	var newList []*EmailStatus
	for i, v := range list {
		if !f(v) {
			listLen := len(list)
			newList = make([]*EmailStatus, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList
		}
	}
	return newList
}

// DropWhileEmailStatusPtrErr drops the items from the list as long as condition satisfies.
//
// Takes two inputs
//	1. Function: takes one input and returns (boolean, error)
//	2. list
//
// Returns:
// 	New List, error
//  Empty list if either one of arguments or both of them are nil
func DropWhileEmailStatusPtrErr(f func(*EmailStatus) (bool, error), list []*EmailStatus) ([]*EmailStatus, error) {
	if f == nil {
		return []*EmailStatus{}, nil
	}
	var newList []*EmailStatus
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			listLen := len(list)
			newList = make([]*EmailStatus, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList, nil
		}
	}
	return newList, nil
}

// DropWhileEmailStatusErr drops the items from the list as long as condition satisfies.
//
// Takes two inputs
//	1. Function: takes one input and returns (boolean, error)
//	2. list
//
// Returns:
// 	New List, error
//  Empty list if either one of arguments or both of them are nil
func DropWhileEmailStatusErr(f func(EmailStatus) (bool, error), list []EmailStatus) ([]EmailStatus, error) {
	if f == nil {
		return []EmailStatus{}, nil
	}
	var newList []EmailStatus
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			listLen := len(list)
			newList = make([]EmailStatus, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList, nil
		}
	}
	return newList, nil
}

func TakeWhileEmailStatus(f func(EmailStatus) bool, list []EmailStatus) []EmailStatus {
	if f == nil {
		return []EmailStatus{}
	}
	var newList []EmailStatus
	for _, v := range list {
		if !f(v) {
			return newList
		}
		newList = append(newList, v)
	}
	return newList
}

func TakeWhileEmailStatusPtr(f func(*EmailStatus) bool, list []*EmailStatus) []*EmailStatus {
	if f == nil {
		return []*EmailStatus{}
	}
	var newList []*EmailStatus
	for _, v := range list {
		if !f(v) {
			return newList
		}
		newList = append(newList, v)
	}
	return newList
}

// TakeWhileEmailStatusPtrErr returns new list based on condition in the supplied function. It returns new list once condition fails.
//
// Takes 2 inputs:
//	1. Function - 1 input of type *EmailStatus and returns ([]*EmailStatus, error)
//	2. List
//
// Returns:
//	New List, error.
//	Empty list if all the parameters are nil or either of one parameter is nil
func TakeWhileEmailStatusPtrErr(f func(*EmailStatus) (bool, error), list []*EmailStatus) ([]*EmailStatus, error) {
	if f == nil {
		return []*EmailStatus{}, nil
	}
	var newList []*EmailStatus
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			return newList, nil
		}
		newList = append(newList, v)
	}
	return newList, nil
}

// TakeWhileEmailStatusErr returns new list based on condition in the supplied function. It returns new list once condition fails.
//
// Takes 2 inputs:
//	1. Function - 1 input of type EmailStatus and returns ([]EmailStatus, error)
//	2. List
//
// Returns:
//	New List, error.
//	Empty list if all the parameters are nil or either of one parameter is nil
func TakeWhileEmailStatusErr(f func(EmailStatus) (bool, error), list []EmailStatus) ([]EmailStatus, error) {
	if f == nil {
		return []EmailStatus{}, nil
	}
	var newList []EmailStatus
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			return newList, nil
		}
		newList = append(newList, v)
	}
	return newList, nil
}

// PMapEmailStatus applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapEmailStatus(f func(EmailStatus) EmailStatus, list []EmailStatus, optional ...fp.Optional) []EmailStatus {
	if f == nil {
		return []EmailStatus{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapEmailStatusNoOrder(f, list, worker)
		}
	}

	return pMapEmailStatusPreserveOrder(f, list, worker)
}

func pMapEmailStatusPreserveOrder(f func(EmailStatus) EmailStatus, list []EmailStatus, worker int) []EmailStatus {
	chJobs := make(chan map[int]EmailStatus, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]EmailStatus{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]EmailStatus, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]EmailStatus, chJobs chan map[int]EmailStatus) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]EmailStatus{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]EmailStatus, len(list))
	newList := make([]EmailStatus, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapEmailStatusNoOrder(f func(EmailStatus) EmailStatus, list []EmailStatus, worker int) []EmailStatus {
	chJobs := make(chan EmailStatus, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan EmailStatus, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan EmailStatus, chJobs chan EmailStatus) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]EmailStatus, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapEmailStatusPtr applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapEmailStatusPtr(f func(*EmailStatus) *EmailStatus, list []*EmailStatus, optional ...fp.Optional) []*EmailStatus {
	if f == nil {
		return []*EmailStatus{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapEmailStatusPtrNoOrder(f, list, worker)
		}
	}

	return pMapEmailStatusPtrPreserveOrder(f, list, worker)
}

func pMapEmailStatusPtrPreserveOrder(f func(*EmailStatus) *EmailStatus, list []*EmailStatus, worker int) []*EmailStatus {
	chJobs := make(chan map[int]*EmailStatus, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*EmailStatus{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*EmailStatus, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*EmailStatus, chJobs chan map[int]*EmailStatus) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]*EmailStatus{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*EmailStatus, len(list))
	newList := make([]*EmailStatus, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapEmailStatusPtrNoOrder(f func(*EmailStatus) *EmailStatus, list []*EmailStatus, worker int) []*EmailStatus {
	chJobs := make(chan *EmailStatus, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *EmailStatus, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *EmailStatus, chJobs chan *EmailStatus) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*EmailStatus, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapEmailStatusPtrErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapEmailStatusPtrErr(f func(*EmailStatus) (*EmailStatus, error), list []*EmailStatus, optional ...fp.Optional) ([]*EmailStatus, error) {
	if f == nil {
		return []*EmailStatus{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapEmailStatusPtrErrNoOrder(f, list, worker)
		}
	}

	return pMapEmailStatusPtrErrPreserveOrder(f, list, worker)
}

func pMapEmailStatusPtrErrPreserveOrder(f func(*EmailStatus) (*EmailStatus, error), list []*EmailStatus, worker int) ([]*EmailStatus, error) {
	chJobs := make(chan map[int]*EmailStatus, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*EmailStatus{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*EmailStatus, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*EmailStatus, chJobs chan map[int]*EmailStatus, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]*EmailStatus{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*EmailStatus, len(list))
	newList := make([]*EmailStatus, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []*EmailStatus{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []*EmailStatus{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapEmailStatusPtrErrNoOrder(f func(*EmailStatus) (*EmailStatus, error), list []*EmailStatus, worker int) ([]*EmailStatus, error) {
	chJobs := make(chan *EmailStatus, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *EmailStatus, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *EmailStatus, chJobs chan *EmailStatus, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*EmailStatus, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []*EmailStatus{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []*EmailStatus{}, <-errCh
	}

	return newList, nil
}

// PMapEmailStatusErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapEmailStatusErr(f func(EmailStatus) (EmailStatus, error), list []EmailStatus, optional ...fp.Optional) ([]EmailStatus, error) {
	if f == nil {
		return []EmailStatus{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapEmailStatusErrNoOrder(f, list, worker)
		}
	}

	return pMapEmailStatusErrPreserveOrder(f, list, worker)
}

func pMapEmailStatusErrPreserveOrder(f func(EmailStatus) (EmailStatus, error), list []EmailStatus, worker int) ([]EmailStatus, error) {
	chJobs := make(chan map[int]EmailStatus, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]EmailStatus{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]EmailStatus, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]EmailStatus, chJobs chan map[int]EmailStatus, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]EmailStatus{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]EmailStatus, len(list))
	newList := make([]EmailStatus, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []EmailStatus{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []EmailStatus{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapEmailStatusErrNoOrder(f func(EmailStatus) (EmailStatus, error), list []EmailStatus, worker int) ([]EmailStatus, error) {
	chJobs := make(chan EmailStatus, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan EmailStatus, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan EmailStatus, chJobs chan EmailStatus, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]EmailStatus, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []EmailStatus{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []EmailStatus{}, <-errCh
	}

	return newList, nil
}

func FilterMapEmailStatus(fFilter func(EmailStatus) bool, fMap func(EmailStatus) EmailStatus, list []EmailStatus) []EmailStatus {
	if fFilter == nil || fMap == nil {
		return []EmailStatus{}
	}
	var newList []EmailStatus
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

func FilterMapEmailStatusPtr(fFilter func(*EmailStatus) bool, fMap func(*EmailStatus) *EmailStatus, list []*EmailStatus) []*EmailStatus {
	if fFilter == nil || fMap == nil {
		return []*EmailStatus{}
	}
	var newList []*EmailStatus
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapEmailStatusPtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input(*EmailStatus) and returns (bool, error).
//	2. Function: takes *EmailStatus as argument and returns (*EmailStatus, error)
// 	3. Slice of type []*EmailStatus
//
// Returns:
//	New List ([]*EmailStatus, error).
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmailStatusPtrErr(fFilter func(*EmailStatus) (bool, error), fMap func(*EmailStatus) (*EmailStatus, error), list []*EmailStatus) ([]*EmailStatus, error) {
	if fFilter == nil || fMap == nil {
		return []*EmailStatus{}, nil
	}
	var newList []*EmailStatus
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapEmailStatusErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input(EmailStatus) and returns (bool, error).
//	2. Function: takes EmailStatus as argument and returns (EmailStatus, error)
// 	3. Slice of type []EmailStatus
//
// Returns:
//	New List ([]EmailStatus, error).
//  Empty list if all there parameters are nil or either of parameter is nil
//
func FilterMapEmailStatusErr(fFilter func(EmailStatus) (bool, error), fMap func(EmailStatus) (EmailStatus, error), list []EmailStatus) ([]EmailStatus, error) {
	if fFilter == nil || fMap == nil {
		return []EmailStatus{}, nil
	}
	var newList []EmailStatus
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

func RestEmailStatus(l []EmailStatus) []EmailStatus {
	if l == nil {
		return []EmailStatus{}
	}

	len := len(l)
	if len == 0 || len == 1 {
		return []EmailStatus{}
	}

	newList := make([]EmailStatus, len-1)

	for i, v := range l[1:] {
		newList[i] = v
	}

	return newList
}


// RestEmailStatus removes 1st item of the list and return new list having rest of the items
func RestEmailStatusPtr(l []*EmailStatus) []*EmailStatus {
	if l == nil {
		return []*EmailStatus{}
	}

	len := len(l)
	if len == 0 || len == 1 {
		return []*EmailStatus{}
	}

	newList := make([]*EmailStatus, len-1)

	for i, v := range l[1:] {
		newList[i] = v
	}

	return newList
}

func ReduceEmailStatus(f func(EmailStatus, EmailStatus) EmailStatus, list []EmailStatus, initializer ...EmailStatus) EmailStatus {
	var init EmailStatus 
	lenList := len(list)

	if initializer != nil {
		init = initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0]
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}
	
	if lenList == 0 {
		return init
	}
	r := f(init, list[0])
	return ReduceEmailStatus(f, list[1:], r)
}

func ReduceEmailStatusPtr(f func(*EmailStatus, *EmailStatus) *EmailStatus, list []*EmailStatus, initializer ...EmailStatus) *EmailStatus {
	var initVal EmailStatus
	var init *EmailStatus = &initVal
	lenList := len(list)

	if initializer != nil {
		init = &initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0]
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init
	}

	r := f(init, list[0])
	return ReduceEmailStatusPtr(f, list[1:], *r)
}

// ReduceEmailStatusPtrErr reduces a list to a single value by combining elements via a supplied function
//
// Takes three inputs
//	A. function - takes two arguments (*EmailStatus, *EmailStatus)
//	B. list of type []*EmailStatus
// 	C. initializer (optional of type EmailStatus)
//
// Returns:
//	single value, error: (*EmailStatus, error)
func ReduceEmailStatusPtrErr(f func(*EmailStatus, *EmailStatus) (*EmailStatus, error), list []*EmailStatus, initializer ...EmailStatus) (*EmailStatus, error) {
	var initVal EmailStatus
	var init *EmailStatus = &initVal
	lenList := len(list)

	if initializer != nil {
		init = &initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0], nil
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init, nil
	}

	r, err := f(init, list[0])
	if err != nil {
		return nil, err
	}
	return ReduceEmailStatusPtrErr(f, list[1:], *r)
}

// ReduceEmailStatusErr reduces a list to a single value by combining elements via a supplied function
//
// Takes three inputs
//	A. function - takes two arguments (EmailStatus, EmailStatus)
//	B. list of type []EmailStatus
// 	C. initializer (optional of type EmailStatus)
//
// Returns:
//	single value, error: (EmailStatus, error)
func ReduceEmailStatusErr(f func(EmailStatus, EmailStatus) (EmailStatus, error), list []EmailStatus, initializer ...EmailStatus) (EmailStatus, error) {
	var initVal EmailStatus
	var init EmailStatus = initVal
	lenList := len(list)

	if initializer != nil {
		init = initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0], nil
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init, nil
	}

	r, err := f(init, list[0])
	if err != nil {
		return r, err
	}
	return ReduceEmailStatusErr(f, list[1:], r)
}

// DropLastEmailStatus drops last item from the list and returns new list.
// Returns empty list if there is only one item in the list or list empty
func DropLastEmailStatus(list []EmailStatus) []EmailStatus {
	listLen := len(list)

	if list == nil || listLen == 0 || listLen == 1 {
		return []EmailStatus{}
	}

	newList := make([]EmailStatus, listLen-1)

	for i := 0; i < listLen-1; i++ {
		newList[i] = list[i]
	}
	return newList
}

// DropLastEmailStatusPtr drops last item from the list and returns new list.
// Returns empty list if there is only one item in the list or list empty
func DropLastEmailStatusPtr(list []*EmailStatus) []*EmailStatus {
	listLen := len(list)

	if list == nil || listLen == 0 || listLen == 1 {
		return []*EmailStatus{}
	}

	newList := make([]*EmailStatus, listLen-1)

	for i := 0; i < listLen-1; i++ {
		newList[i] = list[i]
	}
	return newList
}

// ReverseEmailStatuss reverse the list
func ReverseEmailStatuss(list []EmailStatus) []EmailStatus {
	newList := make([]EmailStatus, len(list))
	for i := 0; i < len(list); i++ {
		newList[i] = list[len(list)-(i+1)]
	}
	return newList
}

// ReverseEmailStatussPtr reverse the list
func ReverseEmailStatussPtr(list []*EmailStatus) []*EmailStatus {
	newList := make([]*EmailStatus, len(list))
	for i := 0; i < len(list); i++ {
		newList[i] = list[len(list)-(i+1)]
	}
	return newList
}

// TakeEmailStatus returns n items in the list
func TakeEmailStatus(n int, list []EmailStatus) []EmailStatus {
	if n < 0 {
		return []EmailStatus{}
	}

	newListLen := len(list)

	if n < newListLen {
		newListLen = n
	}
	newList := make([]EmailStatus, newListLen)
	for i := 0; i < newListLen; i++ {
		newList[i] = list[i]
	}
	return newList
}

// TakeEmailStatusPtr returns n items in the list
func TakeEmailStatusPtr(n int, list []*EmailStatus) []*EmailStatus {
	if n < 0 {
		return []*EmailStatus{}
	}

	newListLen := len(list)

	if n < newListLen {
		newListLen = n
	}
	newList := make([]*EmailStatus, newListLen)
	for i := 0; i < newListLen; i++ {
		newList[i] = list[i]
	}
	return newList
}

// DistinctEmailStatusP returns true if no two of the arguments are =
func DistinctEmailStatusP(list []EmailStatus) bool {
	if len(list) == 0 {
		return false
	}

	s := make(map[EmailStatus]bool)
	for _, v := range list {
		if _, ok := s[v]; ok {
			return false
		}
		s[v] = true
	}
	return true
}

// DistinctEmailStatusPPtr returns true if no two of the arguments are =
func DistinctEmailStatusPPtr(list []*EmailStatus) bool {
	if len(list) == 0 {
		return false
	}

	s := make(map[EmailStatus]bool)
	for _, v := range list {
		if _, ok := s[*v]; ok {
			return false
		}
		s[*v] = true
	}
	return true
}

// DistinctEmailStatus removes duplicates.
func DistinctEmailStatus(list []EmailStatus) []EmailStatus {
	var newList []EmailStatus
	s := make(map[EmailStatus]struct{}, len(list))
	for _, v := range list {
		if _, ok := s[v]; ok {
			continue
		}
		s[v] = struct{}{}
		newList = append(newList, v)
	}
	return newList
}

// DistinctEmailStatusPtr removes duplicates.
func DistinctEmailStatusPtr(list []*EmailStatus) []*EmailStatus {
	var newList []*EmailStatus
	s := make(map[EmailStatus]struct{}, len(list))
	for _, v := range list {
		if _, ok := s[*v]; ok {
			continue
		}
		s[*v] = struct{}{}
		newList = append(newList, v)
	}
	return newList
}

// UnionEmailStatus return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionEmailStatus(arrList ...[]EmailStatus) []EmailStatus {
	resultMap := make(map[EmailStatus]bool)
	for _, arr := range arrList {
		for _, v := range arr {
			resultMap[v] = true
		}
	}

	resultArr := make([]EmailStatus, len(resultMap))
	i := 0
	for k := range resultMap {
		resultArr[i] = k
		i++
	}
	return resultArr
}

// UnionEmailStatusPtr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionEmailStatusPtr(arrList ...[]*EmailStatus) []*EmailStatus {
	resultMap := make(map[EmailStatus]bool)
	var resultArr []*EmailStatus
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[*v]
			if !ok {
				resultMap[*v] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionEmailStatus return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionEmailStatus(arrList ...[]EmailStatus) []EmailStatus {
	if arrList == nil {
		return []EmailStatus{}
	}

	resultMap := make(map[EmailStatus]bool)
	if len(arrList) == 1 {
		var newList []EmailStatus
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i]]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i]] = true
			}
		}
		return newList
	}

	var newList []EmailStatus
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i] == v {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i]]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i]] = true
			}
		}
	}
	return newList
}

// IntersectionEmailStatusPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionEmailStatusPtr(arrList ...[]*EmailStatus) []*EmailStatus {
	if arrList == nil {
		return []*EmailStatus{}
	}

	resultMap := make(map[EmailStatus]bool)
	if len(arrList) == 1 {
		var newList []*EmailStatus
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[*arrList[0][i]]
			if !ok {
				resultMap[*arrList[0][i]] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*EmailStatus
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if *arrList[0][i] == *v {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[*arrList[0][i]]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[*arrList[0][i]] = true
			}
		}
	}
	return newList
}

// DifferenceEmailStatus returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceEmailStatus(arrList ...[]EmailStatus) []EmailStatus {
	if arrList == nil {
		return []EmailStatus{}
	}

	resultMap := make(map[EmailStatus]bool)
	if len(arrList) == 1 {
		var newList []EmailStatus
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i]]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i]] = true
			}
		}
		return newList
	}

	var newList []EmailStatus
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i] == v {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i]]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i]] = true
			}
		}
	}
	return newList
}

// DifferenceEmailStatusPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceEmailStatusPtr(arrList ...[]*EmailStatus) []*EmailStatus {
	if arrList == nil {
		return []*EmailStatus{}
	}

	resultMap := make(map[EmailStatus]bool)
	if len(arrList) == 1 {
		var newList []*EmailStatus
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[*arrList[0][i]]
			if !ok {
				resultMap[*arrList[0][i]] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*EmailStatus
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if *arrList[0][i] == *v {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[*arrList[0][i]]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[*arrList[0][i]] = true
			}
		}
	}
	return newList
}

// SubsetEmailStatus returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetEmailStatus(list1, list2 []EmailStatus) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[EmailStatus]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i]]
		if !ok {
			found := false
			resultMap[list1[i]] = true
			for j := 0; j < len(list2); j++ {
				if list1[i] == list2[j] {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetEmailStatusPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetEmailStatusPtr(list1, list2 []*EmailStatus) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[EmailStatus]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[*list1[i]]
		if !ok {
			found := false
			resultMap[*list1[i]] = true
			for j := 0; j < len(list2); j++ {
				if list1[i] == list2[j] {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetEmailStatus returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetEmailStatus(list1, list2 []EmailStatus) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[EmailStatus]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i]]
		if !ok {
			found := false
			resultMap[list2[i]] = true
			for j := 0; j < len(list1); j++ {
				if list2[i] == list1[j] {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetEmailStatusPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetEmailStatusPtr(list1, list2 []*EmailStatus) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[EmailStatus]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[*list2[i]]
		if !ok {
			found := false
			resultMap[*list2[i]] = true
			for j := 0; j < len(list1); j++ {
				if list2[i] == list1[j] {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetEmailStatus returns a set of the distinct elements of coll.
func SetEmailStatus(list []EmailStatus) []EmailStatus {
	if list == nil || len(list) == 0 {
		return []EmailStatus{}
	}

	resultMap := make(map[EmailStatus]bool)
	newList := []EmailStatus{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i]]
		if !ok {
			resultMap[list[i]] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetEmailStatusPtr returns a set of the distinct elements of coll.
func SetEmailStatusPtr(list []*EmailStatus) []*EmailStatus {
	if list == nil || len(list) == 0 {
		return []*EmailStatus{}
	}

	resultMap := make(map[EmailStatus]bool)
	newList := []*EmailStatus{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[*list[i]]
		if !ok {
			resultMap[*list[i]] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}



type byTypEmailStatus []EmailStatus

func (a byTypEmailStatus) Len() int           { return len(a) }
func (a byTypEmailStatus) Less(i, j int) bool { return a[i].typ < a[j].typ }
func (a byTypEmailStatus) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortEmailStatusByTyp sort structs
func SortEmailStatusByTyp(list []EmailStatus) []EmailStatus {
	if len(list) == 0 {
		return []EmailStatus{}
	}
	newList := make([]EmailStatus, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byTypEmailStatus(newList))
	return newList
}

// SortEmailStatusByTypPtr sorts structs
func SortEmailStatusByTypPtr(list []*EmailStatus) []*EmailStatus {
	if len(list) == 0 {
		return []*EmailStatus{}
	}
	newList := make([]EmailStatus, len(list))
	newListPtr := make([]*EmailStatus, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byTypEmailStatus(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byTypEmailStatusDesc []EmailStatus

func (a byTypEmailStatusDesc) Len() int           { return len(a) }
func (a byTypEmailStatusDesc) Less(i, j int) bool { return a[i].typ > a[j].typ }
func (a byTypEmailStatusDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortEmailStatusByTypDesc sorts structs
func SortEmailStatusByTypDesc(list []EmailStatus) []EmailStatus {
	if len(list) == 0 {
		return []EmailStatus{}
	}
	newList := make([]EmailStatus, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byTypEmailStatusDesc(newList))
	return newList
}

// SortEmailStatusByTypDescPtr sorts structs
func SortEmailStatusByTypDescPtr(list []*EmailStatus) []*EmailStatus {
	if len(list) == 0 {
		return []*EmailStatus{}
	}
	newList := make([]EmailStatus, len(list))
	newListPtr := make([]*EmailStatus, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byTypEmailStatusDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type bySentAtEmailStatus []EmailStatus

func (a bySentAtEmailStatus) Len() int           { return len(a) }
func (a bySentAtEmailStatus) Less(i, j int) bool { return a[i].sentAt.Before(a[j].sentAt) }
func (a bySentAtEmailStatus) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortEmailStatusBySentAt sort structs
func SortEmailStatusBySentAt(list []EmailStatus) []EmailStatus {
	if len(list) == 0 {
		return []EmailStatus{}
	}
	newList := make([]EmailStatus, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(bySentAtEmailStatus(newList))
	return newList
}

// SortEmailStatusBySentAtPtr sorts structs
func SortEmailStatusBySentAtPtr(list []*EmailStatus) []*EmailStatus {
	if len(list) == 0 {
		return []*EmailStatus{}
	}
	newList := make([]EmailStatus, len(list))
	newListPtr := make([]*EmailStatus, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(bySentAtEmailStatus(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type bySentAtEmailStatusDesc []EmailStatus

func (a bySentAtEmailStatusDesc) Len() int           { return len(a) }
func (a bySentAtEmailStatusDesc) Less(i, j int) bool { return a[i].sentAt.After(a[j].sentAt) }
func (a bySentAtEmailStatusDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortEmailStatusBySentAtDesc sorts structs
func SortEmailStatusBySentAtDesc(list []EmailStatus) []EmailStatus {
	if len(list) == 0 {
		return []EmailStatus{}
	}
	newList := make([]EmailStatus, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(bySentAtEmailStatusDesc(newList))
	return newList
}

// SortEmailStatusBySentAtDescPtr sorts structs
func SortEmailStatusBySentAtDescPtr(list []*EmailStatus) []*EmailStatus {
	if len(list) == 0 {
		return []*EmailStatus{}
	}
	newList := make([]EmailStatus, len(list))
	newListPtr := make([]*EmailStatus, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(bySentAtEmailStatusDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
// UnionEmailStatusByTyp return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionEmailStatusByTyp(arrList ...[]EmailStatus) []EmailStatus {
	resultMap := make(map[string]bool)
	var resultArr []EmailStatus
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.typ]
			if !ok {
				resultMap[v.typ] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionEmailStatusByTypPtr(arrList ...[]*EmailStatus) []*EmailStatus {
	resultMap := make(map[string]bool)
	var resultArr []*EmailStatus
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.typ]
			if !ok {
				resultMap[v.typ] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionEmailStatusByTyp return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionEmailStatusByTyp(arrList ...[]EmailStatus) []EmailStatus {
	if arrList == nil {
		return []EmailStatus{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []EmailStatus
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].typ]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].typ] = true
			}
		}
		return newList
	}

	var newList []EmailStatus
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].typ == v.typ {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].typ]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].typ] = true
			}
		}
	}
	return newList
}

// IntersectionEmailStatusByTypPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionEmailStatusByTypPtr(arrList ...[]*EmailStatus) []*EmailStatus {
	if arrList == nil {
		return []*EmailStatus{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*EmailStatus
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].typ]
			if !ok {
				resultMap[arrList[0][i].typ] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*EmailStatus
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].typ == v.typ {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].typ]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].typ] = true
			}
		}
	}
	return newList
}

// DifferenceEmailStatusByTyp returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceEmailStatusByTyp(arrList ...[]EmailStatus) []EmailStatus {
	if arrList == nil {
		return []EmailStatus{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []EmailStatus
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].typ]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].typ] = true
			}
		}
		return newList
	}

	var newList []EmailStatus
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].typ == v.typ {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].typ]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].typ] = true
			}
		}
	}
	return newList
}

// DifferenceEmailStatusByTypPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceEmailStatusByTypPtr(arrList ...[]*EmailStatus) []*EmailStatus {
	if arrList == nil {
		return []*EmailStatus{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*EmailStatus
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].typ]
			if !ok {
				resultMap[arrList[0][i].typ] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*EmailStatus
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].typ == v.typ {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].typ]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].typ] = true
			}
		}
	}
	return newList
}

// SubsetEmailStatusByTyp returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetEmailStatusByTyp(list1, list2 []EmailStatus) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].typ]
		if !ok {
			found := false
			resultMap[list1[i].typ] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].typ == list2[j].typ {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetEmailStatusByTypPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetEmailStatusByTypPtr(list1, list2 []*EmailStatus) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].typ]
		if !ok {
			found := false
			resultMap[list1[i].typ] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].typ == list2[j].typ {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetEmailStatusByTyp returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetEmailStatusByTyp(list1, list2 []EmailStatus) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].typ]
		if !ok {
			found := false
			resultMap[list2[i].typ] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].typ == list1[j].typ {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetEmailStatusByTypPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetEmailStatusByTypPtr(list1, list2 []*EmailStatus) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].typ]
		if !ok {
			found := false
			resultMap[list2[i].typ] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].typ == list1[j].typ {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetEmailStatusByTyp returns a set of the distinct elements of coll.
func SetEmailStatusByTyp(list []EmailStatus) []EmailStatus {
	if list == nil || len(list) == 0 {
		return []EmailStatus{}
	}

	resultMap := make(map[string]bool)
	newList := []EmailStatus{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].typ]
		if !ok {
			resultMap[list[i].typ] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetEmailStatusByTypPtr returns a set of the distinct elements of coll.
func SetEmailStatusByTypPtr(list []*EmailStatus) []*EmailStatus {
	if list == nil || len(list) == 0 {
		return []*EmailStatus{}
	}

	resultMap := make(map[string]bool)
	newList := []*EmailStatus{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].typ]
		if !ok {
			resultMap[list[i].typ] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionEmailStatusBySentAt return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionEmailStatusBySentAt(arrList ...[]EmailStatus) []EmailStatus {
	resultMap := make(map[time.Time]bool)
	var resultArr []EmailStatus
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.sentAt]
			if !ok {
				resultMap[v.sentAt] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionEmailStatusBySentAtPtr(arrList ...[]*EmailStatus) []*EmailStatus {
	resultMap := make(map[time.Time]bool)
	var resultArr []*EmailStatus
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.sentAt]
			if !ok {
				resultMap[v.sentAt] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionEmailStatusBySentAt return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionEmailStatusBySentAt(arrList ...[]EmailStatus) []EmailStatus {
	if arrList == nil {
		return []EmailStatus{}
	}

	resultMap := make(map[time.Time]bool)
	if len(arrList) == 1 {
		var newList []EmailStatus
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].sentAt]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].sentAt] = true
			}
		}
		return newList
	}

	var newList []EmailStatus
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].sentAt == v.sentAt {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].sentAt]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].sentAt] = true
			}
		}
	}
	return newList
}

// IntersectionEmailStatusBySentAtPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionEmailStatusBySentAtPtr(arrList ...[]*EmailStatus) []*EmailStatus {
	if arrList == nil {
		return []*EmailStatus{}
	}

	resultMap := make(map[time.Time]bool)
	if len(arrList) == 1 {
		var newList []*EmailStatus
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].sentAt]
			if !ok {
				resultMap[arrList[0][i].sentAt] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*EmailStatus
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].sentAt == v.sentAt {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].sentAt]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].sentAt] = true
			}
		}
	}
	return newList
}

// DifferenceEmailStatusBySentAt returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceEmailStatusBySentAt(arrList ...[]EmailStatus) []EmailStatus {
	if arrList == nil {
		return []EmailStatus{}
	}

	resultMap := make(map[time.Time]bool)
	if len(arrList) == 1 {
		var newList []EmailStatus
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].sentAt]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].sentAt] = true
			}
		}
		return newList
	}

	var newList []EmailStatus
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].sentAt == v.sentAt {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].sentAt]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].sentAt] = true
			}
		}
	}
	return newList
}

// DifferenceEmailStatusBySentAtPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceEmailStatusBySentAtPtr(arrList ...[]*EmailStatus) []*EmailStatus {
	if arrList == nil {
		return []*EmailStatus{}
	}

	resultMap := make(map[time.Time]bool)
	if len(arrList) == 1 {
		var newList []*EmailStatus
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].sentAt]
			if !ok {
				resultMap[arrList[0][i].sentAt] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*EmailStatus
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].sentAt == v.sentAt {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].sentAt]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].sentAt] = true
			}
		}
	}
	return newList
}

// SubsetEmailStatusBySentAt returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetEmailStatusBySentAt(list1, list2 []EmailStatus) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[time.Time]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].sentAt]
		if !ok {
			found := false
			resultMap[list1[i].sentAt] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].sentAt == list2[j].sentAt {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetEmailStatusBySentAtPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetEmailStatusBySentAtPtr(list1, list2 []*EmailStatus) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[time.Time]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].sentAt]
		if !ok {
			found := false
			resultMap[list1[i].sentAt] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].sentAt == list2[j].sentAt {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetEmailStatusBySentAt returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetEmailStatusBySentAt(list1, list2 []EmailStatus) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[time.Time]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].sentAt]
		if !ok {
			found := false
			resultMap[list2[i].sentAt] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].sentAt == list1[j].sentAt {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetEmailStatusBySentAtPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetEmailStatusBySentAtPtr(list1, list2 []*EmailStatus) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[time.Time]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].sentAt]
		if !ok {
			found := false
			resultMap[list2[i].sentAt] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].sentAt == list1[j].sentAt {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetEmailStatusBySentAt returns a set of the distinct elements of coll.
func SetEmailStatusBySentAt(list []EmailStatus) []EmailStatus {
	if list == nil || len(list) == 0 {
		return []EmailStatus{}
	}

	resultMap := make(map[time.Time]bool)
	newList := []EmailStatus{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].sentAt]
		if !ok {
			resultMap[list[i].sentAt] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetEmailStatusBySentAtPtr returns a set of the distinct elements of coll.
func SetEmailStatusBySentAtPtr(list []*EmailStatus) []*EmailStatus {
	if list == nil || len(list) == 0 {
		return []*EmailStatus{}
	}

	resultMap := make(map[time.Time]bool)
	newList := []*EmailStatus{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].sentAt]
		if !ok {
			resultMap[list[i].sentAt] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}