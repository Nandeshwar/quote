// Code generated by 'gofp'. DO NOT EDIT.
package model
import "reflect" 
import "sort" 
import "sync" 
import "time"
import "github.com/logic-building/functional-go/fp" 

func MapInfo(f func(Info) Info, list []Info) []Info {
	if f == nil {
		return []Info{}
	}
	newList := make([]Info, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

func MapInfoPtr(f func(*Info) *Info, list []*Info) []*Info {
	if f == nil {
		return []*Info{}
	}
	newList := make([]*Info, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapInfoPtrErr takes 2 arguments:
//  1. A function input argument: *Info and return types (*Info, error)
//  2. A list of type []*Info
//
// Returns:
// 	([]*Info, error)
func MapInfoPtrErr(f func(*Info) (*Info, error), list []*Info) ([]*Info, error) {
	if f == nil {
		return []*Info{}, nil
	}
	newList := make([]*Info, len(list))
	for i, v := range list {
		var err error
		newList[i], err = f(v)
		if err != nil {
			return nil, err
		}
	}
	return newList, nil
}

// MapInfoErr takes 2 arguments:
//  1. A function input argument: Info and return types (Info, error)
//  2. A list of type []Info
//
// Returns:
// 	([]Info, error)
func MapInfoErr(f func(Info) (Info, error), list []Info) ([]Info, error) {
	if f == nil {
		return []Info{}, nil
	}
	newList := make([]Info, len(list))
	for i, v := range list {
		var err error
		newList[i], err = f(v)
		if err != nil {
			return nil, err
		}
	}
	return newList, nil
}

func FilterInfo(f func(Info) bool, list []Info) []Info {
	if f == nil {
		return []Info{}
	}
	var newList []Info
	for _, v := range list {
		if f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

func FilterInfoPtr(f func(*Info) bool, list []*Info) []*Info {
	if f == nil {
		return []*Info{}
	}
	var newList []*Info
	for _, v := range list {
		if f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

// FilterInfoPtrErr takes two arguments
//  1. Function: takes 1 argument of type Info and returns (bool, error)
//  2. slice of type []*Info
//
// Returns:
//  new filtered list and error
func FilterInfoPtrErr(f func(*Info) (bool, error), list []*Info) ([]*Info, error) {
	if f == nil {
		return []*Info{}, nil
	}
	var newList []*Info
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

// FilterInfoErr takes two arguments
//  1. Function: takes 1 argument of type Info and returns (bool, error)
//  2. slice of type []Info
//
// Returns:
//  new filtered list and error
func FilterInfoErr(f func(Info) (bool, error), list []Info) ([]Info, error) {
	if f == nil {
		return []Info{}, nil
	}
	var newList []Info
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

func RemoveInfo(f func(Info) bool, list []Info) []Info {
	if f == nil {
		return []Info{}
	}
	var newList []Info
	for _, v := range list {
		if !f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

func RemoveInfoPtr(f func(*Info) bool, list []*Info) []*Info {
	if f == nil {
		return []*Info{}
	}
	var newList []*Info
	for _, v := range list {
		if !f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

// RemoveInfoPtrErr removes the items from the given list based on supplied function and returns new list
//
// Takes 2 inputs:
//	1. Function: input type *Info and return types(bool, error)
//	2. List of type: []*Info
//
// Returns:
//	New list and error: ([]*Info, error)
//	Empty list if both of arguments are nil or either one is nil.
func RemoveInfoPtrErr(f func(*Info) (bool, error), list []*Info) ([]*Info, error) {
	if f == nil {
		return []*Info{}, nil
	}
	var newList []*Info
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

// RemoveInfoErr removes the items from the given list based on supplied function and returns new list
//
// Takes 2 inputs:
//	1. Function: input type Info and return types(bool, error)
//	2. List of type: []Info
//
// Returns:
//	New list and error: ([]Info, error)
//	Empty list if both of arguments are nil or either one is nil.
func RemoveInfoErr(f func(Info) (bool, error), list []Info) ([]Info, error) {
	if f == nil {
		return []Info{}, nil
	}
	var newList []Info
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

func SomeInfo(f func(Info) bool, list []Info) bool {
	if f == nil {
		return false
	}
	for _, v := range list {
		if f(v) {
			return true
		}
	}
	return false
}

func SomeInfoPtr(f func(*Info) bool, list []*Info) bool {
	if f == nil {
		return false
	}
	for _, v := range list {
		if f(v) {
			return true
		}
	}
	return false
}

// SomeInfoPtrErr finds item in the list based on supplied function.
//
// Takes 2 input:
//	1. Function
//	2. List
//
// Returns:
//	(bool,err).
//	True if condition satisfies, else false
func SomeInfoPtrErr(f func(*Info) (bool, error), list []*Info) (bool, error) {
	if f == nil {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if r {
			return true, nil
		}
	}
	return false, nil
}

// SomeInfoErr finds item in the list based on supplied function.
//
// Takes 2 input:
//	1. Function
//	2. List
//
// Returns:
//	(bool,err).
//	True if condition satisfies, else false
func SomeInfoErr(f func(Info) (bool, error), list []Info) (bool, error) {
	if f == nil {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if r {
			return true, nil
		}
	}
	return false, nil
}

func EveryInfo(f func(Info) bool, list []Info) bool {
	if f == nil || len(list) == 0 {
		return false
	}
	for _, v := range list {
		if !f(v) {
			return false
		}
	}
	return true
}

func EveryInfoPtr(f func(*Info) bool, list []*Info) bool {
	if f == nil || len(list) == 0 {
		return false
	}
	for _, v := range list {
		if !f(v) {
			return false
		}
	}
	return true
}

// EveryInfoPtrErr returns true if supplied function returns logical true for every item in the list
func EveryInfoPtrErr(f func(*Info) (bool, error), list []*Info) (bool, error) {
	if f == nil || len(list) == 0 {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if !r {
			return false, nil
		}
	}
	return true, nil
}

// EveryInfoErr returns true if supplied function returns logical true for every item in the list
func EveryInfoErr(f func(Info) (bool, error), list []Info) (bool, error) {
	if f == nil || len(list) == 0 {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if !r {
			return false, nil
		}
	}
	return true, nil
}

func DropWhileInfo(f func(Info) bool, list []Info) []Info {
	if f == nil {
		return []Info{}
	}
	var newList []Info
	for i, v := range list {
		if !f(v) {
			listLen := len(list)
			newList = make([]Info, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList
		}
	}
	return newList
}

func DropWhileInfoPtr(f func(*Info) bool, list []*Info) []*Info {
	if f == nil {
		return []*Info{}
	}
	var newList []*Info
	for i, v := range list {
		if !f(v) {
			listLen := len(list)
			newList = make([]*Info, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList
		}
	}
	return newList
}

// DropWhileInfoPtrErr drops the items from the list as long as condition satisfies.
//
// Takes two inputs
//	1. Function: takes one input and returns (boolean, error)
//	2. list
//
// Returns:
// 	New List, error
//  Empty list if either one of arguments or both of them are nil
func DropWhileInfoPtrErr(f func(*Info) (bool, error), list []*Info) ([]*Info, error) {
	if f == nil {
		return []*Info{}, nil
	}
	var newList []*Info
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			listLen := len(list)
			newList = make([]*Info, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList, nil
		}
	}
	return newList, nil
}

// DropWhileInfoErr drops the items from the list as long as condition satisfies.
//
// Takes two inputs
//	1. Function: takes one input and returns (boolean, error)
//	2. list
//
// Returns:
// 	New List, error
//  Empty list if either one of arguments or both of them are nil
func DropWhileInfoErr(f func(Info) (bool, error), list []Info) ([]Info, error) {
	if f == nil {
		return []Info{}, nil
	}
	var newList []Info
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			listLen := len(list)
			newList = make([]Info, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList, nil
		}
	}
	return newList, nil
}

func TakeWhileInfo(f func(Info) bool, list []Info) []Info {
	if f == nil {
		return []Info{}
	}
	var newList []Info
	for _, v := range list {
		if !f(v) {
			return newList
		}
		newList = append(newList, v)
	}
	return newList
}

func TakeWhileInfoPtr(f func(*Info) bool, list []*Info) []*Info {
	if f == nil {
		return []*Info{}
	}
	var newList []*Info
	for _, v := range list {
		if !f(v) {
			return newList
		}
		newList = append(newList, v)
	}
	return newList
}

// TakeWhileInfoPtrErr returns new list based on condition in the supplied function. It returns new list once condition fails.
//
// Takes 2 inputs:
//	1. Function - 1 input of type *Info and returns ([]*Info, error)
//	2. List
//
// Returns:
//	New List, error.
//	Empty list if all the parameters are nil or either of one parameter is nil
func TakeWhileInfoPtrErr(f func(*Info) (bool, error), list []*Info) ([]*Info, error) {
	if f == nil {
		return []*Info{}, nil
	}
	var newList []*Info
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			return newList, nil
		}
		newList = append(newList, v)
	}
	return newList, nil
}

// TakeWhileInfoErr returns new list based on condition in the supplied function. It returns new list once condition fails.
//
// Takes 2 inputs:
//	1. Function - 1 input of type Info and returns ([]Info, error)
//	2. List
//
// Returns:
//	New List, error.
//	Empty list if all the parameters are nil or either of one parameter is nil
func TakeWhileInfoErr(f func(Info) (bool, error), list []Info) ([]Info, error) {
	if f == nil {
		return []Info{}, nil
	}
	var newList []Info
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			return newList, nil
		}
		newList = append(newList, v)
	}
	return newList, nil
}

// PMapInfo applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapInfo(f func(Info) Info, list []Info, optional ...fp.Optional) []Info {
	if f == nil {
		return []Info{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapInfoNoOrder(f, list, worker)
		}
	}

	return pMapInfoPreserveOrder(f, list, worker)
}

func pMapInfoPreserveOrder(f func(Info) Info, list []Info, worker int) []Info {
	chJobs := make(chan map[int]Info, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]Info{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]Info, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]Info, chJobs chan map[int]Info) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]Info{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]Info, len(list))
	newList := make([]Info, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapInfoNoOrder(f func(Info) Info, list []Info, worker int) []Info {
	chJobs := make(chan Info, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan Info, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan Info, chJobs chan Info) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]Info, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapInfoPtr applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapInfoPtr(f func(*Info) *Info, list []*Info, optional ...fp.Optional) []*Info {
	if f == nil {
		return []*Info{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapInfoPtrNoOrder(f, list, worker)
		}
	}

	return pMapInfoPtrPreserveOrder(f, list, worker)
}

func pMapInfoPtrPreserveOrder(f func(*Info) *Info, list []*Info, worker int) []*Info {
	chJobs := make(chan map[int]*Info, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*Info{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*Info, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*Info, chJobs chan map[int]*Info) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]*Info{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*Info, len(list))
	newList := make([]*Info, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapInfoPtrNoOrder(f func(*Info) *Info, list []*Info, worker int) []*Info {
	chJobs := make(chan *Info, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *Info, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *Info, chJobs chan *Info) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*Info, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapInfoPtrErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapInfoPtrErr(f func(*Info) (*Info, error), list []*Info, optional ...fp.Optional) ([]*Info, error) {
	if f == nil {
		return []*Info{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapInfoPtrErrNoOrder(f, list, worker)
		}
	}

	return pMapInfoPtrErrPreserveOrder(f, list, worker)
}

func pMapInfoPtrErrPreserveOrder(f func(*Info) (*Info, error), list []*Info, worker int) ([]*Info, error) {
	chJobs := make(chan map[int]*Info, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*Info{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*Info, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*Info, chJobs chan map[int]*Info, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]*Info{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*Info, len(list))
	newList := make([]*Info, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []*Info{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []*Info{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapInfoPtrErrNoOrder(f func(*Info) (*Info, error), list []*Info, worker int) ([]*Info, error) {
	chJobs := make(chan *Info, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *Info, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *Info, chJobs chan *Info, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*Info, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []*Info{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []*Info{}, <-errCh
	}

	return newList, nil
}

// PMapInfoErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapInfoErr(f func(Info) (Info, error), list []Info, optional ...fp.Optional) ([]Info, error) {
	if f == nil {
		return []Info{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapInfoErrNoOrder(f, list, worker)
		}
	}

	return pMapInfoErrPreserveOrder(f, list, worker)
}

func pMapInfoErrPreserveOrder(f func(Info) (Info, error), list []Info, worker int) ([]Info, error) {
	chJobs := make(chan map[int]Info, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]Info{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]Info, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]Info, chJobs chan map[int]Info, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]Info{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]Info, len(list))
	newList := make([]Info, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []Info{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []Info{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapInfoErrNoOrder(f func(Info) (Info, error), list []Info, worker int) ([]Info, error) {
	chJobs := make(chan Info, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan Info, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan Info, chJobs chan Info, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]Info, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []Info{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []Info{}, <-errCh
	}

	return newList, nil
}

func FilterMapInfo(fFilter func(Info) bool, fMap func(Info) Info, list []Info) []Info {
	if fFilter == nil || fMap == nil {
		return []Info{}
	}
	var newList []Info
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

func FilterMapInfoPtr(fFilter func(*Info) bool, fMap func(*Info) *Info, list []*Info) []*Info {
	if fFilter == nil || fMap == nil {
		return []*Info{}
	}
	var newList []*Info
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapInfoPtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input(*Info) and returns (bool, error).
//	2. Function: takes *Info as argument and returns (*Info, error)
// 	3. Slice of type []*Info
//
// Returns:
//	New List ([]*Info, error).
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapInfoPtrErr(fFilter func(*Info) (bool, error), fMap func(*Info) (*Info, error), list []*Info) ([]*Info, error) {
	if fFilter == nil || fMap == nil {
		return []*Info{}, nil
	}
	var newList []*Info
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapInfoErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input(Info) and returns (bool, error).
//	2. Function: takes Info as argument and returns (Info, error)
// 	3. Slice of type []Info
//
// Returns:
//	New List ([]Info, error).
//  Empty list if all there parameters are nil or either of parameter is nil
//
func FilterMapInfoErr(fFilter func(Info) (bool, error), fMap func(Info) (Info, error), list []Info) ([]Info, error) {
	if fFilter == nil || fMap == nil {
		return []Info{}, nil
	}
	var newList []Info
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

func RestInfo(l []Info) []Info {
	if l == nil {
		return []Info{}
	}

	len := len(l)
	if len == 0 || len == 1 {
		return []Info{}
	}

	newList := make([]Info, len-1)

	for i, v := range l[1:] {
		newList[i] = v
	}

	return newList
}


// RestInfo removes 1st item of the list and return new list having rest of the items
func RestInfoPtr(l []*Info) []*Info {
	if l == nil {
		return []*Info{}
	}

	len := len(l)
	if len == 0 || len == 1 {
		return []*Info{}
	}

	newList := make([]*Info, len-1)

	for i, v := range l[1:] {
		newList[i] = v
	}

	return newList
}

func ReduceInfo(f func(Info, Info) Info, list []Info, initializer ...Info) Info {
	var init Info 
	lenList := len(list)

	if initializer != nil {
		init = initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0]
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}
	
	if lenList == 0 {
		return init
	}
	r := f(init, list[0])
	return ReduceInfo(f, list[1:], r)
}

func ReduceInfoPtr(f func(*Info, *Info) *Info, list []*Info, initializer ...Info) *Info {
	var initVal Info
	var init *Info = &initVal
	lenList := len(list)

	if initializer != nil {
		init = &initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0]
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init
	}

	r := f(init, list[0])
	return ReduceInfoPtr(f, list[1:], *r)
}

// ReduceInfoPtrErr reduces a list to a single value by combining elements via a supplied function
//
// Takes three inputs
//	A. function - takes two arguments (*Info, *Info)
//	B. list of type []*Info
// 	C. initializer (optional of type Info)
//
// Returns:
//	single value, error: (*Info, error)
func ReduceInfoPtrErr(f func(*Info, *Info) (*Info, error), list []*Info, initializer ...Info) (*Info, error) {
	var initVal Info
	var init *Info = &initVal
	lenList := len(list)

	if initializer != nil {
		init = &initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0], nil
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init, nil
	}

	r, err := f(init, list[0])
	if err != nil {
		return nil, err
	}
	return ReduceInfoPtrErr(f, list[1:], *r)
}

// ReduceInfoErr reduces a list to a single value by combining elements via a supplied function
//
// Takes three inputs
//	A. function - takes two arguments (Info, Info)
//	B. list of type []Info
// 	C. initializer (optional of type Info)
//
// Returns:
//	single value, error: (Info, error)
func ReduceInfoErr(f func(Info, Info) (Info, error), list []Info, initializer ...Info) (Info, error) {
	var initVal Info
	var init Info = initVal
	lenList := len(list)

	if initializer != nil {
		init = initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0], nil
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init, nil
	}

	r, err := f(init, list[0])
	if err != nil {
		return r, err
	}
	return ReduceInfoErr(f, list[1:], r)
}

// DropLastInfo drops last item from the list and returns new list.
// Returns empty list if there is only one item in the list or list empty
func DropLastInfo(list []Info) []Info {
	listLen := len(list)

	if list == nil || listLen == 0 || listLen == 1 {
		return []Info{}
	}

	newList := make([]Info, listLen-1)

	for i := 0; i < listLen-1; i++ {
		newList[i] = list[i]
	}
	return newList
}

// DropLastInfoPtr drops last item from the list and returns new list.
// Returns empty list if there is only one item in the list or list empty
func DropLastInfoPtr(list []*Info) []*Info {
	listLen := len(list)

	if list == nil || listLen == 0 || listLen == 1 {
		return []*Info{}
	}

	newList := make([]*Info, listLen-1)

	for i := 0; i < listLen-1; i++ {
		newList[i] = list[i]
	}
	return newList
}

// ReverseInfos reverse the list
func ReverseInfos(list []Info) []Info {
	newList := make([]Info, len(list))
	for i := 0; i < len(list); i++ {
		newList[i] = list[len(list)-(i+1)]
	}
	return newList
}

// ReverseInfosPtr reverse the list
func ReverseInfosPtr(list []*Info) []*Info {
	newList := make([]*Info, len(list))
	for i := 0; i < len(list); i++ {
		newList[i] = list[len(list)-(i+1)]
	}
	return newList
}

// TakeInfo returns n items in the list
func TakeInfo(n int, list []Info) []Info {
	if n < 0 {
		return []Info{}
	}

	newListLen := len(list)

	if n < newListLen {
		newListLen = n
	}
	newList := make([]Info, newListLen)
	for i := 0; i < newListLen; i++ {
		newList[i] = list[i]
	}
	return newList
}

// TakeInfoPtr returns n items in the list
func TakeInfoPtr(n int, list []*Info) []*Info {
	if n < 0 {
		return []*Info{}
	}

	newListLen := len(list)

	if n < newListLen {
		newListLen = n
	}
	newList := make([]*Info, newListLen)
	for i := 0; i < newListLen; i++ {
		newList[i] = list[i]
	}
	return newList
}

// DistinctInfoP returns true if no two of the arguments are =
func DistinctInfoP(list []Info) bool {
	if len(list) == 0 {
		return false
	}

	for i := 0; i < len(list); i++ {
		for j := i + 1; j < len(list); j++ {
			if reflect.DeepEqual(list[i], list[j]) {
				return false
			}
		}
	}
	return true
}

// DistinctInfoPPtr returns true if no two of the arguments are =
func DistinctInfoPPtr(list []*Info) bool {
	if len(list) == 0 {
		return false
	}

	for i := 0; i < len(list); i++ {
		for j := i + 1; j < len(list); j++ {
			if reflect.DeepEqual(*list[i], *list[j]) {
				return false
			}
		}
	}
	return true
}

// DistinctInfo removes duplicates.
func DistinctInfo(list []Info) []Info {
	if len(list) == 0 {
		return []Info{}
	}

	newList := []Info{list[0]}

	for i := 1; i < len(list); i++ {
		found := false
		for j := 0; j < len(newList); j++ {
			if reflect.DeepEqual(list[i], newList[j]) {
				found = true
				break
			}
		}
		if !found {
			newList = append(newList, list[i])
		}
	}
	return newList
}

func DistinctInfoPtr(list []*Info) []*Info {
	if len(list) == 0 {
		return []*Info{}
	}

	newList := []*Info{list[0]}

	for i := 1; i < len(list); i++ {
		found := false
		for j := 0; j < len(newList); j++ {
			if reflect.DeepEqual(*list[i], *newList[j]) {
				found = true
				break
			}
		}
		if !found {
			newList = append(newList, list[i])
		}
	}
	return newList
}

// UnionInfo return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionInfo(arrList ...[]Info) []Info {
	var newList []Info

	for _, arr := range arrList {
		for _, v := range arr {
			found := false
			for i := 0; i < len(newList); i++ {
				if reflect.DeepEqual(newList[i], v) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, v)
			}
		}
	}
	return newList
}

// UnionInfoPtr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionInfoPtr(arrList ...[]*Info) []*Info {
	var newList []*Info

	for _, arr := range arrList {
		for _, v := range arr {
			found := false
			for i := 0; i < len(newList); i++ {
				if reflect.DeepEqual(*newList[i], *v) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, v)
			}
		}
	}
	return newList
}

// IntersectionInfo return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionInfo(arrList ...[]Info) []Info {
	if arrList == nil {
		return []Info{}
	}

	var newList []Info

	if len(arrList) == 1 {
		for i := 0; i < len(arrList[0]); i++ {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(newList[j], arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if reflect.DeepEqual(arrList[0][i], v) {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(newList[j], arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
	}
	return newList
}

// IntersectionInfoPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionInfoPtr(arrList ...[]*Info) []*Info {
	if arrList == nil {
		return []*Info{}
	}

	var newList []*Info

	if len(arrList) == 1 {
		for i := 0; i < len(arrList[0]); i++ {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(*newList[j], *arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if reflect.DeepEqual(*arrList[0][i], *v) {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(*newList[j], *arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
	}
	return newList
}

// DifferenceInfo returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceInfo(arrList ...[]Info) []Info {
	if arrList == nil {
		return []Info{}
	}

	var newList []Info

	if len(arrList) == 1 {
		for i := 0; i < len(arrList[0]); i++ {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(newList[j], arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if reflect.DeepEqual(arrList[0][i], v) {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(newList[j], arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
	}
	return newList
}

// DifferenceInfoPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceInfoPtr(arrList ...[]*Info) []*Info {
	if arrList == nil {
		return []*Info{}
	}

	var newList []*Info

	if len(arrList) == 1 {
		for i := 0; i < len(arrList[0]); i++ {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(*newList[j], *arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if reflect.DeepEqual(*arrList[0][i], *v) {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(*newList[j], *arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
	}
	return newList
}

// SubsetInfo returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored, order does not matter
func SubsetInfo(list1, list2 []Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	for i := 0; i < len(list1); i++ {
		found := false
		for j := 0; j < len(list2); j++ {
			if reflect.DeepEqual(list1[i], list2[j]) {
				found = true
			}
		}
		if !found {
			return false
		}
	}
	return true
}

// SubsetInfoPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored, order does not matter
func SubsetInfoPtr(list1, list2 []*Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	for i := 0; i < len(list1); i++ {
		found := false
		for j := 0; j < len(list2); j++ {
			if reflect.DeepEqual(*list1[i], *list2[j]) {
				found = true
			}
		}
		if !found {
			return false
		}
	}
	return true
}

// SupersetInfo returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored, order does not matter
func SupersetInfo(list1, list2 []Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	for i := 0; i < len(list2); i++ {
		found := false
		for j := 0; j < len(list1); j++ {
			if reflect.DeepEqual(list2[i], list1[j]) {
				found = true
			}
		}
		if !found {
			return false
		}
	}
	return true
}

// SupersetInfoPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored, order does not matter
func SupersetInfoPtr(list1, list2 []*Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	for i := 0; i < len(list2); i++ {
		found := false
		for j := 0; j < len(list1); j++ {
			if reflect.DeepEqual(*list2[i], *list1[j]) {
				found = true
			}
		}
		if !found {
			return false
		}
	}
	return true
}

// SetInfo returns a set of the distinct elements of coll.
func SetInfo(list []Info) []Info {
	if len(list) == 0 {
		return []Info{}
	}

	newList := []Info{list[0]}

	for i := 1; i < len(list); i++ {
		found := false
		for j := 0; j < len(newList); j++ {
			if reflect.DeepEqual(list[i], newList[j]) {
				found = true
				break
			}
		}
		if !found {
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetInfoPtr returns a set of the distinct elements of coll.
func SetInfoPtr(list []*Info) []*Info {
	if len(list) == 0 {
		return []*Info{}
	}

	newList := []*Info{list[0]}

	for i := 1; i < len(list); i++ {
		found := false
		for j := 0; j < len(newList); j++ {
			if reflect.DeepEqual(*list[i], *newList[j]) {
				found = true
				break
			}
		}
		if !found {
			newList = append(newList, list[i])
		}
	}
	return newList
}


// MapInfoStr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapInfoStr(f func(Info) string, list []Info) []string {
	if f == nil {
		return []string{}
	}
	newList := make([]string, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapInfoStrErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list and error
func MapInfoStrErr(f func(Info) (string, error), list []Info) ([]string, error) {
	if f == nil {
		return []string{}, nil
	}
	newList := make([]string, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// MapInfoStrPtr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapInfoStrPtr(f func(*Info) *string, list []*Info) []*string {
	if f == nil {
		return []*string{}
	}
	newList := make([]*string, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapInfoStrPtrErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list, error
func MapInfoStrPtrErr(f func(*Info) (*string, error), list []*Info) ([]*string, error) {
	if f == nil {
		return []*string{}, nil
	}
	newList := make([]*string, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// PMapInfoStr applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapInfoStr(f func(Info) string, list []Info, optional ...fp.Optional) []string {
	if f == nil {
		return []string{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapInfoStrNoOrder(f, list, worker)
		}
	}

	return pMapInfoStrPreserveOrder(f, list, worker)
}

func pMapInfoStrPreserveOrder(f func(Info) string, list []Info, worker int) []string {
	chJobs := make(chan map[int]Info, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]Info{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]string, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]string, chJobs chan map[int]Info) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]string{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]string, len(list))
	newList := make([]string, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapInfoStrNoOrder(f func(Info) string, list []Info, worker int) []string {
	chJobs := make(chan Info, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan string, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan string, chJobs chan Info) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]string, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapInfoStrErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapInfoStrErr(f func(Info) (string, error), list []Info, optional ...fp.Optional) ([]string, error) {
	if f == nil {
		return []string{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapInfoStrErrNoOrder(f, list, worker)
		}
	}

	return pMapInfoStrErrPreserveOrder(f, list, worker)
}

func pMapInfoStrErrPreserveOrder(f func(Info) (string, error), list []Info, worker int) ([]string, error) {
	chJobs := make(chan map[int]Info, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]Info{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]string, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]string, chJobs chan map[int]Info, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]string{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]string, len(list))
	newList := make([]string, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []string{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []string{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapInfoStrErrNoOrder(f func(Info) (string, error), list []Info, worker int) ([]string, error) {
	chJobs := make(chan Info, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan string, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan string, chJobs chan Info, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]string, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []string{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []string{}, <-errCh
	}

	return newList, nil
}

// PMapInfoStrPtr applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapInfoStrPtr(f func(*Info) *string, list []*Info, optional ...fp.Optional) []*string {
	if f == nil {
		return []*string{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapInfoStrPtrNoOrder(f, list, worker)
		}
	}

	return pMapInfoStrPtrPreserveOrder(f, list, worker)
}

func pMapInfoStrPtrPreserveOrder(f func(*Info) *string, list []*Info, worker int) []*string {
	chJobs := make(chan map[int]*Info, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*Info{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*string, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*string, chJobs chan map[int]*Info) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]*string{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*string, len(list))
	newList := make([]*string, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapInfoStrPtrNoOrder(f func(*Info) *string, list []*Info, worker int) []*string {
	chJobs := make(chan *Info, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *string, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *string, chJobs chan *Info) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*string, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapInfoStrPtrErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapInfoStrPtrErr(f func(*Info) (*string, error), list []*Info, optional ...fp.Optional) ([]*string, error) {
	if f == nil {
		return []*string{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapInfoStrPtrErrNoOrder(f, list, worker)
		}
	}

	return pMapInfoStrPtrErrPreserveOrder(f, list, worker)
}

func pMapInfoStrPtrErrPreserveOrder(f func(*Info) (*string, error), list []*Info, worker int) ([]*string, error) {
	chJobs := make(chan map[int]*Info, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*Info{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*string, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*string, chJobs chan map[int]*Info, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]*string{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*string, len(list))
	newList := make([]*string, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []*string{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []*string{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapInfoStrPtrErrNoOrder(f func(*Info) (*string, error), list []*Info, worker int) ([]*string, error) {
	chJobs := make(chan *Info, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *string, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *string, chJobs chan *Info, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*string, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []*string{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []*string{}, <-errCh
	}

	return newList, nil
}

// FilterMapInfoStr filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input type - Info and returns true/false.
//	2. Function: takes Info as argument and returns string
// 	3. List of type Info
//
// Returns:
//	New List of type string
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapInfoStr(fFilter func(Info) bool, fMap func(Info) string, list []Info) []string {
	if fFilter == nil || fMap == nil {
		return []string{}
	}
	var newList []string
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapInfoStrPtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - *Info and returns (bool, error).
//	2. Function: takes *Info as argument and returns (*string, error)
// 	3. List of type *Info
//
// Returns:
//	New List of type *string, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapInfoStrPtrErr(fFilter func(*Info) (bool, error), fMap func(*Info) (*string, error), list []*Info) ([]*string, error) {
	if fFilter == nil || fMap == nil {
		return []*string{}, nil
	}
	var newList []*string
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapInfoStrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - Info and returns (bool, error).
//	2. Function: takes Info as argument and returns (string, error)
// 	3. List of type Info
//
// Returns:
//	New List of type string, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapInfoStrErr(fFilter func(Info) (bool, error), fMap func(Info) (string, error), list []Info) ([]string, error) {
	if fFilter == nil || fMap == nil {
		return []string{}, nil
	}
	var newList []string
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// MapStrInfo takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapStrInfo(f func(string) Info, list []string) []Info {
	if f == nil {
		return []Info{}
	}
	newList := make([]Info, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapStrInfoErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list and error
func MapStrInfoErr(f func(string) (Info, error), list []string) ([]Info, error) {
	if f == nil {
		return []Info{}, nil
	}
	newList := make([]Info, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// MapStrInfoPtr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapStrInfoPtr(f func(*string) *Info, list []*string) []*Info {
	if f == nil {
		return []*Info{}
	}
	newList := make([]*Info, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapStrInfoPtrErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list, error
func MapStrInfoPtrErr(f func(*string) (*Info, error), list []*string) ([]*Info, error) {
	if f == nil {
		return []*Info{}, nil
	}
	newList := make([]*Info, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// PMapStrInfo applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapStrInfo(f func(string) Info, list []string, optional ...fp.Optional) []Info {
	if f == nil {
		return []Info{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapStrInfoNoOrder(f, list, worker)
		}
	}

	return pMapStrInfoPreserveOrder(f, list, worker)
}

func pMapStrInfoPreserveOrder(f func(string) Info, list []string, worker int) []Info {
	chJobs := make(chan map[int]string, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]string{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]Info, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]Info, chJobs chan map[int]string) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]Info{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]Info, len(list))
	newList := make([]Info, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapStrInfoNoOrder(f func(string) Info, list []string, worker int) []Info {
	chJobs := make(chan string, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan Info, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan Info, chJobs chan string) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]Info, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapStrInfoErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapStrInfoErr(f func(string) (Info, error), list []string, optional ...fp.Optional) ([]Info, error) {
	if f == nil {
		return []Info{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapStrInfoErrNoOrder(f, list, worker)
		}
	}

	return pMapStrInfoErrPreserveOrder(f, list, worker)
}

func pMapStrInfoErrPreserveOrder(f func(string) (Info, error), list []string, worker int) ([]Info, error) {
	chJobs := make(chan map[int]string, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]string{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]Info, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]Info, chJobs chan map[int]string, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]Info{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]Info, len(list))
	newList := make([]Info, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []Info{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []Info{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapStrInfoErrNoOrder(f func(string) (Info, error), list []string, worker int) ([]Info, error) {
	chJobs := make(chan string, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan Info, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan Info, chJobs chan string, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]Info, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []Info{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []Info{}, <-errCh
	}

	return newList, nil
}

// PMapStrInfoPtr applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapStrInfoPtr(f func(*string) *Info, list []*string, optional ...fp.Optional) []*Info {
	if f == nil {
		return []*Info{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapStrInfoPtrNoOrder(f, list, worker)
		}
	}

	return pMapStrInfoPtrPreserveOrder(f, list, worker)
}

func pMapStrInfoPtrPreserveOrder(f func(*string) *Info, list []*string, worker int) []*Info {
	chJobs := make(chan map[int]*string, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*string{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*Info, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*Info, chJobs chan map[int]*string) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]*Info{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*Info, len(list))
	newList := make([]*Info, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapStrInfoPtrNoOrder(f func(*string) *Info, list []*string, worker int) []*Info {
	chJobs := make(chan *string, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *Info, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *Info, chJobs chan *string) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*Info, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapStrInfoPtrErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapStrInfoPtrErr(f func(*string) (*Info, error), list []*string, optional ...fp.Optional) ([]*Info, error) {
	if f == nil {
		return []*Info{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapStrInfoPtrErrNoOrder(f, list, worker)
		}
	}

	return pMapStrInfoPtrErrPreserveOrder(f, list, worker)
}

func pMapStrInfoPtrErrPreserveOrder(f func(*string) (*Info, error), list []*string, worker int) ([]*Info, error) {
	chJobs := make(chan map[int]*string, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*string{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*Info, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*Info, chJobs chan map[int]*string, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]*Info{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*Info, len(list))
	newList := make([]*Info, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []*Info{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []*Info{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapStrInfoPtrErrNoOrder(f func(*string) (*Info, error), list []*string, worker int) ([]*Info, error) {
	chJobs := make(chan *string, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *Info, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *Info, chJobs chan *string, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*Info, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []*Info{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []*Info{}, <-errCh
	}

	return newList, nil
}

// FilterMapStrInfo filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input type - string and returns true/false.
//	2. Function: takes string as argument and returns Info
// 	3. List of type string
//
// Returns:
//	New List of type Info
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapStrInfo(fFilter func(string) bool, fMap func(string) Info, list []string) []Info {
	if fFilter == nil || fMap == nil {
		return []Info{}
	}
	var newList []Info
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapStrInfoPtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - *string and returns (bool, error).
//	2. Function: takes *string as argument and returns (*Info, error)
// 	3. List of type *string
//
// Returns:
//	New List of type *Info, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapStrInfoPtrErr(fFilter func(*string) (bool, error), fMap func(*string) (*Info, error), list []*string) ([]*Info, error) {
	if fFilter == nil || fMap == nil {
		return []*Info{}, nil
	}
	var newList []*Info
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapStrInfoErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - string and returns (bool, error).
//	2. Function: takes string as argument and returns (Info, error)
// 	3. List of type string
//
// Returns:
//	New List of type Info, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapStrInfoErr(fFilter func(string) (bool, error), fMap func(string) (Info, error), list []string) ([]Info, error) {
	if fFilter == nil || fMap == nil {
		return []Info{}, nil
	}
	var newList []Info
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}


type byIDInfo []Info

func (a byIDInfo) Len() int           { return len(a) }
func (a byIDInfo) Less(i, j int) bool { return a[i].ID < a[j].ID }
func (a byIDInfo) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortInfoByID sort structs
func SortInfoByID(list []Info) []Info {
	if len(list) == 0 {
		return []Info{}
	}
	newList := make([]Info, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byIDInfo(newList))
	return newList
}

// SortInfoByIDPtr sorts structs
func SortInfoByIDPtr(list []*Info) []*Info {
	if len(list) == 0 {
		return []*Info{}
	}
	newList := make([]Info, len(list))
	newListPtr := make([]*Info, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byIDInfo(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byIDInfoDesc []Info

func (a byIDInfoDesc) Len() int           { return len(a) }
func (a byIDInfoDesc) Less(i, j int) bool { return a[i].ID > a[j].ID }
func (a byIDInfoDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortInfoByIDDesc sorts structs
func SortInfoByIDDesc(list []Info) []Info {
	if len(list) == 0 {
		return []Info{}
	}
	newList := make([]Info, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byIDInfoDesc(newList))
	return newList
}

// SortInfoByIDDescPtr sorts structs
func SortInfoByIDDescPtr(list []*Info) []*Info {
	if len(list) == 0 {
		return []*Info{}
	}
	newList := make([]Info, len(list))
	newListPtr := make([]*Info, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byIDInfoDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byTitleInfo []Info

func (a byTitleInfo) Len() int           { return len(a) }
func (a byTitleInfo) Less(i, j int) bool { return a[i].Title < a[j].Title }
func (a byTitleInfo) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortInfoByTitle sort structs
func SortInfoByTitle(list []Info) []Info {
	if len(list) == 0 {
		return []Info{}
	}
	newList := make([]Info, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byTitleInfo(newList))
	return newList
}

// SortInfoByTitlePtr sorts structs
func SortInfoByTitlePtr(list []*Info) []*Info {
	if len(list) == 0 {
		return []*Info{}
	}
	newList := make([]Info, len(list))
	newListPtr := make([]*Info, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byTitleInfo(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byTitleInfoDesc []Info

func (a byTitleInfoDesc) Len() int           { return len(a) }
func (a byTitleInfoDesc) Less(i, j int) bool { return a[i].Title > a[j].Title }
func (a byTitleInfoDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortInfoByTitleDesc sorts structs
func SortInfoByTitleDesc(list []Info) []Info {
	if len(list) == 0 {
		return []Info{}
	}
	newList := make([]Info, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byTitleInfoDesc(newList))
	return newList
}

// SortInfoByTitleDescPtr sorts structs
func SortInfoByTitleDescPtr(list []*Info) []*Info {
	if len(list) == 0 {
		return []*Info{}
	}
	newList := make([]Info, len(list))
	newListPtr := make([]*Info, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byTitleInfoDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byInfoInfo []Info

func (a byInfoInfo) Len() int           { return len(a) }
func (a byInfoInfo) Less(i, j int) bool { return a[i].Info < a[j].Info }
func (a byInfoInfo) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortInfoByInfo sort structs
func SortInfoByInfo(list []Info) []Info {
	if len(list) == 0 {
		return []Info{}
	}
	newList := make([]Info, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byInfoInfo(newList))
	return newList
}

// SortInfoByInfoPtr sorts structs
func SortInfoByInfoPtr(list []*Info) []*Info {
	if len(list) == 0 {
		return []*Info{}
	}
	newList := make([]Info, len(list))
	newListPtr := make([]*Info, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byInfoInfo(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byInfoInfoDesc []Info

func (a byInfoInfoDesc) Len() int           { return len(a) }
func (a byInfoInfoDesc) Less(i, j int) bool { return a[i].Info > a[j].Info }
func (a byInfoInfoDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortInfoByInfoDesc sorts structs
func SortInfoByInfoDesc(list []Info) []Info {
	if len(list) == 0 {
		return []Info{}
	}
	newList := make([]Info, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byInfoInfoDesc(newList))
	return newList
}

// SortInfoByInfoDescPtr sorts structs
func SortInfoByInfoDescPtr(list []*Info) []*Info {
	if len(list) == 0 {
		return []*Info{}
	}
	newList := make([]Info, len(list))
	newListPtr := make([]*Info, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byInfoInfoDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byLinkInfo []Info

func (a byLinkInfo) Len() int           { return len(a) }
func (a byLinkInfo) Less(i, j int) bool { return a[i].Link < a[j].Link }
func (a byLinkInfo) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortInfoByLink sort structs
func SortInfoByLink(list []Info) []Info {
	if len(list) == 0 {
		return []Info{}
	}
	newList := make([]Info, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byLinkInfo(newList))
	return newList
}

// SortInfoByLinkPtr sorts structs
func SortInfoByLinkPtr(list []*Info) []*Info {
	if len(list) == 0 {
		return []*Info{}
	}
	newList := make([]Info, len(list))
	newListPtr := make([]*Info, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byLinkInfo(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byLinkInfoDesc []Info

func (a byLinkInfoDesc) Len() int           { return len(a) }
func (a byLinkInfoDesc) Less(i, j int) bool { return a[i].Link > a[j].Link }
func (a byLinkInfoDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortInfoByLinkDesc sorts structs
func SortInfoByLinkDesc(list []Info) []Info {
	if len(list) == 0 {
		return []Info{}
	}
	newList := make([]Info, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byLinkInfoDesc(newList))
	return newList
}

// SortInfoByLinkDescPtr sorts structs
func SortInfoByLinkDescPtr(list []*Info) []*Info {
	if len(list) == 0 {
		return []*Info{}
	}
	newList := make([]Info, len(list))
	newListPtr := make([]*Info, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byLinkInfoDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byCreatedAtInfo []Info

func (a byCreatedAtInfo) Len() int           { return len(a) }
func (a byCreatedAtInfo) Less(i, j int) bool { return a[i].CreatedAt.Before(a[j].CreatedAt) }
func (a byCreatedAtInfo) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortInfoByCreatedAt sort structs
func SortInfoByCreatedAt(list []Info) []Info {
	if len(list) == 0 {
		return []Info{}
	}
	newList := make([]Info, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byCreatedAtInfo(newList))
	return newList
}

// SortInfoByCreatedAtPtr sorts structs
func SortInfoByCreatedAtPtr(list []*Info) []*Info {
	if len(list) == 0 {
		return []*Info{}
	}
	newList := make([]Info, len(list))
	newListPtr := make([]*Info, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byCreatedAtInfo(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byCreatedAtInfoDesc []Info

func (a byCreatedAtInfoDesc) Len() int           { return len(a) }
func (a byCreatedAtInfoDesc) Less(i, j int) bool { return a[i].CreatedAt.After(a[j].CreatedAt) }
func (a byCreatedAtInfoDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortInfoByCreatedAtDesc sorts structs
func SortInfoByCreatedAtDesc(list []Info) []Info {
	if len(list) == 0 {
		return []Info{}
	}
	newList := make([]Info, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byCreatedAtInfoDesc(newList))
	return newList
}

// SortInfoByCreatedAtDescPtr sorts structs
func SortInfoByCreatedAtDescPtr(list []*Info) []*Info {
	if len(list) == 0 {
		return []*Info{}
	}
	newList := make([]Info, len(list))
	newListPtr := make([]*Info, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byCreatedAtInfoDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byUpdatedAtInfo []Info

func (a byUpdatedAtInfo) Len() int           { return len(a) }
func (a byUpdatedAtInfo) Less(i, j int) bool { return a[i].UpdatedAt.Before(a[j].UpdatedAt) }
func (a byUpdatedAtInfo) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortInfoByUpdatedAt sort structs
func SortInfoByUpdatedAt(list []Info) []Info {
	if len(list) == 0 {
		return []Info{}
	}
	newList := make([]Info, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byUpdatedAtInfo(newList))
	return newList
}

// SortInfoByUpdatedAtPtr sorts structs
func SortInfoByUpdatedAtPtr(list []*Info) []*Info {
	if len(list) == 0 {
		return []*Info{}
	}
	newList := make([]Info, len(list))
	newListPtr := make([]*Info, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byUpdatedAtInfo(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byUpdatedAtInfoDesc []Info

func (a byUpdatedAtInfoDesc) Len() int           { return len(a) }
func (a byUpdatedAtInfoDesc) Less(i, j int) bool { return a[i].UpdatedAt.After(a[j].UpdatedAt) }
func (a byUpdatedAtInfoDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortInfoByUpdatedAtDesc sorts structs
func SortInfoByUpdatedAtDesc(list []Info) []Info {
	if len(list) == 0 {
		return []Info{}
	}
	newList := make([]Info, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byUpdatedAtInfoDesc(newList))
	return newList
}

// SortInfoByUpdatedAtDescPtr sorts structs
func SortInfoByUpdatedAtDescPtr(list []*Info) []*Info {
	if len(list) == 0 {
		return []*Info{}
	}
	newList := make([]Info, len(list))
	newListPtr := make([]*Info, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byUpdatedAtInfoDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
// UnionInfoByID return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionInfoByID(arrList ...[]Info) []Info {
	resultMap := make(map[int64]bool)
	var resultArr []Info
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.ID]
			if !ok {
				resultMap[v.ID] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionInfoByIDPtr(arrList ...[]*Info) []*Info {
	resultMap := make(map[int64]bool)
	var resultArr []*Info
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.ID]
			if !ok {
				resultMap[v.ID] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionInfoByID return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionInfoByID(arrList ...[]Info) []Info {
	if arrList == nil {
		return []Info{}
	}

	resultMap := make(map[int64]bool)
	if len(arrList) == 1 {
		var newList []Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].ID]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ID] = true
			}
		}
		return newList
	}

	var newList []Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].ID == v.ID {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].ID]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ID] = true
			}
		}
	}
	return newList
}

// IntersectionInfoByIDPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionInfoByIDPtr(arrList ...[]*Info) []*Info {
	if arrList == nil {
		return []*Info{}
	}

	resultMap := make(map[int64]bool)
	if len(arrList) == 1 {
		var newList []*Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].ID]
			if !ok {
				resultMap[arrList[0][i].ID] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].ID == v.ID {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].ID]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ID] = true
			}
		}
	}
	return newList
}

// DifferenceInfoByID returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceInfoByID(arrList ...[]Info) []Info {
	if arrList == nil {
		return []Info{}
	}

	resultMap := make(map[int64]bool)
	if len(arrList) == 1 {
		var newList []Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].ID]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ID] = true
			}
		}
		return newList
	}

	var newList []Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].ID == v.ID {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].ID]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ID] = true
			}
		}
	}
	return newList
}

// DifferenceInfoByIDPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceInfoByIDPtr(arrList ...[]*Info) []*Info {
	if arrList == nil {
		return []*Info{}
	}

	resultMap := make(map[int64]bool)
	if len(arrList) == 1 {
		var newList []*Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].ID]
			if !ok {
				resultMap[arrList[0][i].ID] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].ID == v.ID {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].ID]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ID] = true
			}
		}
	}
	return newList
}

// SubsetInfoByID returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetInfoByID(list1, list2 []Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].ID]
		if !ok {
			found := false
			resultMap[list1[i].ID] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].ID == list2[j].ID {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetInfoByIDPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetInfoByIDPtr(list1, list2 []*Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].ID]
		if !ok {
			found := false
			resultMap[list1[i].ID] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].ID == list2[j].ID {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetInfoByID returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetInfoByID(list1, list2 []Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].ID]
		if !ok {
			found := false
			resultMap[list2[i].ID] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].ID == list1[j].ID {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetInfoByIDPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetInfoByIDPtr(list1, list2 []*Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].ID]
		if !ok {
			found := false
			resultMap[list2[i].ID] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].ID == list1[j].ID {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetInfoByID returns a set of the distinct elements of coll.
func SetInfoByID(list []Info) []Info {
	if list == nil || len(list) == 0 {
		return []Info{}
	}

	resultMap := make(map[int64]bool)
	newList := []Info{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].ID]
		if !ok {
			resultMap[list[i].ID] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetInfoByIDPtr returns a set of the distinct elements of coll.
func SetInfoByIDPtr(list []*Info) []*Info {
	if list == nil || len(list) == 0 {
		return []*Info{}
	}

	resultMap := make(map[int64]bool)
	newList := []*Info{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].ID]
		if !ok {
			resultMap[list[i].ID] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionInfoByTitle return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionInfoByTitle(arrList ...[]Info) []Info {
	resultMap := make(map[string]bool)
	var resultArr []Info
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Title]
			if !ok {
				resultMap[v.Title] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionInfoByTitlePtr(arrList ...[]*Info) []*Info {
	resultMap := make(map[string]bool)
	var resultArr []*Info
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Title]
			if !ok {
				resultMap[v.Title] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionInfoByTitle return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionInfoByTitle(arrList ...[]Info) []Info {
	if arrList == nil {
		return []Info{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Title]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Title] = true
			}
		}
		return newList
	}

	var newList []Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Title == v.Title {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Title]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Title] = true
			}
		}
	}
	return newList
}

// IntersectionInfoByTitlePtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionInfoByTitlePtr(arrList ...[]*Info) []*Info {
	if arrList == nil {
		return []*Info{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Title]
			if !ok {
				resultMap[arrList[0][i].Title] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Title == v.Title {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Title]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Title] = true
			}
		}
	}
	return newList
}

// DifferenceInfoByTitle returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceInfoByTitle(arrList ...[]Info) []Info {
	if arrList == nil {
		return []Info{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Title]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Title] = true
			}
		}
		return newList
	}

	var newList []Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Title == v.Title {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Title]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Title] = true
			}
		}
	}
	return newList
}

// DifferenceInfoByTitlePtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceInfoByTitlePtr(arrList ...[]*Info) []*Info {
	if arrList == nil {
		return []*Info{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Title]
			if !ok {
				resultMap[arrList[0][i].Title] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Title == v.Title {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Title]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Title] = true
			}
		}
	}
	return newList
}

// SubsetInfoByTitle returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetInfoByTitle(list1, list2 []Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Title]
		if !ok {
			found := false
			resultMap[list1[i].Title] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Title == list2[j].Title {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetInfoByTitlePtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetInfoByTitlePtr(list1, list2 []*Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Title]
		if !ok {
			found := false
			resultMap[list1[i].Title] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Title == list2[j].Title {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetInfoByTitle returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetInfoByTitle(list1, list2 []Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Title]
		if !ok {
			found := false
			resultMap[list2[i].Title] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Title == list1[j].Title {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetInfoByTitlePtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetInfoByTitlePtr(list1, list2 []*Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Title]
		if !ok {
			found := false
			resultMap[list2[i].Title] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Title == list1[j].Title {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetInfoByTitle returns a set of the distinct elements of coll.
func SetInfoByTitle(list []Info) []Info {
	if list == nil || len(list) == 0 {
		return []Info{}
	}

	resultMap := make(map[string]bool)
	newList := []Info{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Title]
		if !ok {
			resultMap[list[i].Title] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetInfoByTitlePtr returns a set of the distinct elements of coll.
func SetInfoByTitlePtr(list []*Info) []*Info {
	if list == nil || len(list) == 0 {
		return []*Info{}
	}

	resultMap := make(map[string]bool)
	newList := []*Info{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Title]
		if !ok {
			resultMap[list[i].Title] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionInfoByInfo return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionInfoByInfo(arrList ...[]Info) []Info {
	resultMap := make(map[string]bool)
	var resultArr []Info
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Info]
			if !ok {
				resultMap[v.Info] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionInfoByInfoPtr(arrList ...[]*Info) []*Info {
	resultMap := make(map[string]bool)
	var resultArr []*Info
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Info]
			if !ok {
				resultMap[v.Info] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionInfoByInfo return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionInfoByInfo(arrList ...[]Info) []Info {
	if arrList == nil {
		return []Info{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Info]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Info] = true
			}
		}
		return newList
	}

	var newList []Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Info == v.Info {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Info]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Info] = true
			}
		}
	}
	return newList
}

// IntersectionInfoByInfoPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionInfoByInfoPtr(arrList ...[]*Info) []*Info {
	if arrList == nil {
		return []*Info{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Info]
			if !ok {
				resultMap[arrList[0][i].Info] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Info == v.Info {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Info]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Info] = true
			}
		}
	}
	return newList
}

// DifferenceInfoByInfo returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceInfoByInfo(arrList ...[]Info) []Info {
	if arrList == nil {
		return []Info{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Info]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Info] = true
			}
		}
		return newList
	}

	var newList []Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Info == v.Info {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Info]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Info] = true
			}
		}
	}
	return newList
}

// DifferenceInfoByInfoPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceInfoByInfoPtr(arrList ...[]*Info) []*Info {
	if arrList == nil {
		return []*Info{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Info]
			if !ok {
				resultMap[arrList[0][i].Info] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Info == v.Info {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Info]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Info] = true
			}
		}
	}
	return newList
}

// SubsetInfoByInfo returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetInfoByInfo(list1, list2 []Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Info]
		if !ok {
			found := false
			resultMap[list1[i].Info] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Info == list2[j].Info {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetInfoByInfoPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetInfoByInfoPtr(list1, list2 []*Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Info]
		if !ok {
			found := false
			resultMap[list1[i].Info] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Info == list2[j].Info {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetInfoByInfo returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetInfoByInfo(list1, list2 []Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Info]
		if !ok {
			found := false
			resultMap[list2[i].Info] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Info == list1[j].Info {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetInfoByInfoPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetInfoByInfoPtr(list1, list2 []*Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Info]
		if !ok {
			found := false
			resultMap[list2[i].Info] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Info == list1[j].Info {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetInfoByInfo returns a set of the distinct elements of coll.
func SetInfoByInfo(list []Info) []Info {
	if list == nil || len(list) == 0 {
		return []Info{}
	}

	resultMap := make(map[string]bool)
	newList := []Info{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Info]
		if !ok {
			resultMap[list[i].Info] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetInfoByInfoPtr returns a set of the distinct elements of coll.
func SetInfoByInfoPtr(list []*Info) []*Info {
	if list == nil || len(list) == 0 {
		return []*Info{}
	}

	resultMap := make(map[string]bool)
	newList := []*Info{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Info]
		if !ok {
			resultMap[list[i].Info] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionInfoByLink return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionInfoByLink(arrList ...[]Info) []Info {
	resultMap := make(map[string]bool)
	var resultArr []Info
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Link]
			if !ok {
				resultMap[v.Link] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionInfoByLinkPtr(arrList ...[]*Info) []*Info {
	resultMap := make(map[string]bool)
	var resultArr []*Info
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Link]
			if !ok {
				resultMap[v.Link] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionInfoByLink return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionInfoByLink(arrList ...[]Info) []Info {
	if arrList == nil {
		return []Info{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Link]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Link] = true
			}
		}
		return newList
	}

	var newList []Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Link == v.Link {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Link]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Link] = true
			}
		}
	}
	return newList
}

// IntersectionInfoByLinkPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionInfoByLinkPtr(arrList ...[]*Info) []*Info {
	if arrList == nil {
		return []*Info{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Link]
			if !ok {
				resultMap[arrList[0][i].Link] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Link == v.Link {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Link]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Link] = true
			}
		}
	}
	return newList
}

// DifferenceInfoByLink returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceInfoByLink(arrList ...[]Info) []Info {
	if arrList == nil {
		return []Info{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Link]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Link] = true
			}
		}
		return newList
	}

	var newList []Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Link == v.Link {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Link]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Link] = true
			}
		}
	}
	return newList
}

// DifferenceInfoByLinkPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceInfoByLinkPtr(arrList ...[]*Info) []*Info {
	if arrList == nil {
		return []*Info{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Link]
			if !ok {
				resultMap[arrList[0][i].Link] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Link == v.Link {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Link]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Link] = true
			}
		}
	}
	return newList
}

// SubsetInfoByLink returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetInfoByLink(list1, list2 []Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Link]
		if !ok {
			found := false
			resultMap[list1[i].Link] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Link == list2[j].Link {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetInfoByLinkPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetInfoByLinkPtr(list1, list2 []*Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Link]
		if !ok {
			found := false
			resultMap[list1[i].Link] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Link == list2[j].Link {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetInfoByLink returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetInfoByLink(list1, list2 []Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Link]
		if !ok {
			found := false
			resultMap[list2[i].Link] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Link == list1[j].Link {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetInfoByLinkPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetInfoByLinkPtr(list1, list2 []*Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Link]
		if !ok {
			found := false
			resultMap[list2[i].Link] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Link == list1[j].Link {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetInfoByLink returns a set of the distinct elements of coll.
func SetInfoByLink(list []Info) []Info {
	if list == nil || len(list) == 0 {
		return []Info{}
	}

	resultMap := make(map[string]bool)
	newList := []Info{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Link]
		if !ok {
			resultMap[list[i].Link] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetInfoByLinkPtr returns a set of the distinct elements of coll.
func SetInfoByLinkPtr(list []*Info) []*Info {
	if list == nil || len(list) == 0 {
		return []*Info{}
	}

	resultMap := make(map[string]bool)
	newList := []*Info{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Link]
		if !ok {
			resultMap[list[i].Link] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionInfoByCreatedAt return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionInfoByCreatedAt(arrList ...[]Info) []Info {
	resultMap := make(map[time.Time]bool)
	var resultArr []Info
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.CreatedAt]
			if !ok {
				resultMap[v.CreatedAt] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionInfoByCreatedAtPtr(arrList ...[]*Info) []*Info {
	resultMap := make(map[time.Time]bool)
	var resultArr []*Info
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.CreatedAt]
			if !ok {
				resultMap[v.CreatedAt] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionInfoByCreatedAt return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionInfoByCreatedAt(arrList ...[]Info) []Info {
	if arrList == nil {
		return []Info{}
	}

	resultMap := make(map[time.Time]bool)
	if len(arrList) == 1 {
		var newList []Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].CreatedAt]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].CreatedAt] = true
			}
		}
		return newList
	}

	var newList []Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].CreatedAt == v.CreatedAt {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].CreatedAt]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].CreatedAt] = true
			}
		}
	}
	return newList
}

// IntersectionInfoByCreatedAtPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionInfoByCreatedAtPtr(arrList ...[]*Info) []*Info {
	if arrList == nil {
		return []*Info{}
	}

	resultMap := make(map[time.Time]bool)
	if len(arrList) == 1 {
		var newList []*Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].CreatedAt]
			if !ok {
				resultMap[arrList[0][i].CreatedAt] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].CreatedAt == v.CreatedAt {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].CreatedAt]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].CreatedAt] = true
			}
		}
	}
	return newList
}

// DifferenceInfoByCreatedAt returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceInfoByCreatedAt(arrList ...[]Info) []Info {
	if arrList == nil {
		return []Info{}
	}

	resultMap := make(map[time.Time]bool)
	if len(arrList) == 1 {
		var newList []Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].CreatedAt]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].CreatedAt] = true
			}
		}
		return newList
	}

	var newList []Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].CreatedAt == v.CreatedAt {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].CreatedAt]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].CreatedAt] = true
			}
		}
	}
	return newList
}

// DifferenceInfoByCreatedAtPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceInfoByCreatedAtPtr(arrList ...[]*Info) []*Info {
	if arrList == nil {
		return []*Info{}
	}

	resultMap := make(map[time.Time]bool)
	if len(arrList) == 1 {
		var newList []*Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].CreatedAt]
			if !ok {
				resultMap[arrList[0][i].CreatedAt] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].CreatedAt == v.CreatedAt {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].CreatedAt]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].CreatedAt] = true
			}
		}
	}
	return newList
}

// SubsetInfoByCreatedAt returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetInfoByCreatedAt(list1, list2 []Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[time.Time]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].CreatedAt]
		if !ok {
			found := false
			resultMap[list1[i].CreatedAt] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].CreatedAt == list2[j].CreatedAt {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetInfoByCreatedAtPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetInfoByCreatedAtPtr(list1, list2 []*Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[time.Time]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].CreatedAt]
		if !ok {
			found := false
			resultMap[list1[i].CreatedAt] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].CreatedAt == list2[j].CreatedAt {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetInfoByCreatedAt returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetInfoByCreatedAt(list1, list2 []Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[time.Time]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].CreatedAt]
		if !ok {
			found := false
			resultMap[list2[i].CreatedAt] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].CreatedAt == list1[j].CreatedAt {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetInfoByCreatedAtPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetInfoByCreatedAtPtr(list1, list2 []*Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[time.Time]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].CreatedAt]
		if !ok {
			found := false
			resultMap[list2[i].CreatedAt] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].CreatedAt == list1[j].CreatedAt {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetInfoByCreatedAt returns a set of the distinct elements of coll.
func SetInfoByCreatedAt(list []Info) []Info {
	if list == nil || len(list) == 0 {
		return []Info{}
	}

	resultMap := make(map[time.Time]bool)
	newList := []Info{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].CreatedAt]
		if !ok {
			resultMap[list[i].CreatedAt] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetInfoByCreatedAtPtr returns a set of the distinct elements of coll.
func SetInfoByCreatedAtPtr(list []*Info) []*Info {
	if list == nil || len(list) == 0 {
		return []*Info{}
	}

	resultMap := make(map[time.Time]bool)
	newList := []*Info{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].CreatedAt]
		if !ok {
			resultMap[list[i].CreatedAt] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionInfoByUpdatedAt return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionInfoByUpdatedAt(arrList ...[]Info) []Info {
	resultMap := make(map[time.Time]bool)
	var resultArr []Info
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.UpdatedAt]
			if !ok {
				resultMap[v.UpdatedAt] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionInfoByUpdatedAtPtr(arrList ...[]*Info) []*Info {
	resultMap := make(map[time.Time]bool)
	var resultArr []*Info
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.UpdatedAt]
			if !ok {
				resultMap[v.UpdatedAt] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionInfoByUpdatedAt return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionInfoByUpdatedAt(arrList ...[]Info) []Info {
	if arrList == nil {
		return []Info{}
	}

	resultMap := make(map[time.Time]bool)
	if len(arrList) == 1 {
		var newList []Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].UpdatedAt]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].UpdatedAt] = true
			}
		}
		return newList
	}

	var newList []Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].UpdatedAt == v.UpdatedAt {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].UpdatedAt]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].UpdatedAt] = true
			}
		}
	}
	return newList
}

// IntersectionInfoByUpdatedAtPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionInfoByUpdatedAtPtr(arrList ...[]*Info) []*Info {
	if arrList == nil {
		return []*Info{}
	}

	resultMap := make(map[time.Time]bool)
	if len(arrList) == 1 {
		var newList []*Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].UpdatedAt]
			if !ok {
				resultMap[arrList[0][i].UpdatedAt] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].UpdatedAt == v.UpdatedAt {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].UpdatedAt]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].UpdatedAt] = true
			}
		}
	}
	return newList
}

// DifferenceInfoByUpdatedAt returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceInfoByUpdatedAt(arrList ...[]Info) []Info {
	if arrList == nil {
		return []Info{}
	}

	resultMap := make(map[time.Time]bool)
	if len(arrList) == 1 {
		var newList []Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].UpdatedAt]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].UpdatedAt] = true
			}
		}
		return newList
	}

	var newList []Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].UpdatedAt == v.UpdatedAt {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].UpdatedAt]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].UpdatedAt] = true
			}
		}
	}
	return newList
}

// DifferenceInfoByUpdatedAtPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceInfoByUpdatedAtPtr(arrList ...[]*Info) []*Info {
	if arrList == nil {
		return []*Info{}
	}

	resultMap := make(map[time.Time]bool)
	if len(arrList) == 1 {
		var newList []*Info
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].UpdatedAt]
			if !ok {
				resultMap[arrList[0][i].UpdatedAt] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Info
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].UpdatedAt == v.UpdatedAt {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].UpdatedAt]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].UpdatedAt] = true
			}
		}
	}
	return newList
}

// SubsetInfoByUpdatedAt returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetInfoByUpdatedAt(list1, list2 []Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[time.Time]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].UpdatedAt]
		if !ok {
			found := false
			resultMap[list1[i].UpdatedAt] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].UpdatedAt == list2[j].UpdatedAt {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetInfoByUpdatedAtPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetInfoByUpdatedAtPtr(list1, list2 []*Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[time.Time]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].UpdatedAt]
		if !ok {
			found := false
			resultMap[list1[i].UpdatedAt] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].UpdatedAt == list2[j].UpdatedAt {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetInfoByUpdatedAt returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetInfoByUpdatedAt(list1, list2 []Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[time.Time]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].UpdatedAt]
		if !ok {
			found := false
			resultMap[list2[i].UpdatedAt] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].UpdatedAt == list1[j].UpdatedAt {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetInfoByUpdatedAtPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetInfoByUpdatedAtPtr(list1, list2 []*Info) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[time.Time]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].UpdatedAt]
		if !ok {
			found := false
			resultMap[list2[i].UpdatedAt] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].UpdatedAt == list1[j].UpdatedAt {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetInfoByUpdatedAt returns a set of the distinct elements of coll.
func SetInfoByUpdatedAt(list []Info) []Info {
	if list == nil || len(list) == 0 {
		return []Info{}
	}

	resultMap := make(map[time.Time]bool)
	newList := []Info{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].UpdatedAt]
		if !ok {
			resultMap[list[i].UpdatedAt] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetInfoByUpdatedAtPtr returns a set of the distinct elements of coll.
func SetInfoByUpdatedAtPtr(list []*Info) []*Info {
	if list == nil || len(list) == 0 {
		return []*Info{}
	}

	resultMap := make(map[time.Time]bool)
	newList := []*Info{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].UpdatedAt]
		if !ok {
			resultMap[list[i].UpdatedAt] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}