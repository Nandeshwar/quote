// Code generated by 'gofp'. DO NOT EDIT.
package event
import "sort" 
import "sync" 
import "time"

func MapEventDetail(f func(EventDetail) EventDetail, list []EventDetail) []EventDetail {
	if f == nil {
		return []EventDetail{}
	}
	newList := make([]EventDetail, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

func MapEventDetailPtr(f func(*EventDetail) *EventDetail, list []*EventDetail) []*EventDetail {
	if f == nil {
		return []*EventDetail{}
	}
	newList := make([]*EventDetail, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapEventDetailPtrErr takes 2 arguments:
//  1. A function input argument: *EventDetail and return types (*EventDetail, error)
//  2. A list of type []*EventDetail
//
// Returns:
// 	([]*EventDetail, error)
func MapEventDetailPtrErr(f func(*EventDetail) (*EventDetail, error), list []*EventDetail) ([]*EventDetail, error) {
	if f == nil {
		return []*EventDetail{}, nil
	}
	newList := make([]*EventDetail, len(list))
	for i, v := range list {
		var err error
		newList[i], err = f(v)
		if err != nil {
			return nil, err
		}
	}
	return newList, nil
}

// MapEventDetailErr takes 2 arguments:
//  1. A function input argument: EventDetail and return types (EventDetail, error)
//  2. A list of type []EventDetail
//
// Returns:
// 	([]EventDetail, error)
func MapEventDetailErr(f func(EventDetail) (EventDetail, error), list []EventDetail) ([]EventDetail, error) {
	if f == nil {
		return []EventDetail{}, nil
	}
	newList := make([]EventDetail, len(list))
	for i, v := range list {
		var err error
		newList[i], err = f(v)
		if err != nil {
			return nil, err
		}
	}
	return newList, nil
}

func FilterEventDetail(f func(EventDetail) bool, list []EventDetail) []EventDetail {
	if f == nil {
		return []EventDetail{}
	}
	var newList []EventDetail
	for _, v := range list {
		if f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

func FilterEventDetailPtr(f func(*EventDetail) bool, list []*EventDetail) []*EventDetail {
	if f == nil {
		return []*EventDetail{}
	}
	var newList []*EventDetail
	for _, v := range list {
		if f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

// FilterEventDetailPtrErr takes two arguments
//  1. Function: takes 1 argument of type EventDetail and returns (bool, error)
//  2. slice of type []*EventDetail
//
// Returns:
//  new filtered list and error
func FilterEventDetailPtrErr(f func(*EventDetail) (bool, error), list []*EventDetail) ([]*EventDetail, error) {
	if f == nil {
		return []*EventDetail{}, nil
	}
	var newList []*EventDetail
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

// FilterEventDetailErr takes two arguments
//  1. Function: takes 1 argument of type EventDetail and returns (bool, error)
//  2. slice of type []EventDetail
//
// Returns:
//  new filtered list and error
func FilterEventDetailErr(f func(EventDetail) (bool, error), list []EventDetail) ([]EventDetail, error) {
	if f == nil {
		return []EventDetail{}, nil
	}
	var newList []EventDetail
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

func RemoveEventDetail(f func(EventDetail) bool, list []EventDetail) []EventDetail {
	if f == nil {
		return []EventDetail{}
	}
	var newList []EventDetail
	for _, v := range list {
		if !f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

func RemoveEventDetailPtr(f func(*EventDetail) bool, list []*EventDetail) []*EventDetail {
	if f == nil {
		return []*EventDetail{}
	}
	var newList []*EventDetail
	for _, v := range list {
		if !f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

// RemoveEventDetailPtrErr removes the items from the given list based on supplied function and returns new list
//
// Takes 2 inputs:
//	1. Function: input type *EventDetail and return types(bool, error)
//	2. List of type: []*EventDetail
//
// Returns:
//	New list and error: ([]*EventDetail, error)
//	Empty list if both of arguments are nil or either one is nil.
func RemoveEventDetailPtrErr(f func(*EventDetail) (bool, error), list []*EventDetail) ([]*EventDetail, error) {
	if f == nil {
		return []*EventDetail{}, nil
	}
	var newList []*EventDetail
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

// RemoveEventDetailErr removes the items from the given list based on supplied function and returns new list
//
// Takes 2 inputs:
//	1. Function: input type EventDetail and return types(bool, error)
//	2. List of type: []EventDetail
//
// Returns:
//	New list and error: ([]EventDetail, error)
//	Empty list if both of arguments are nil or either one is nil.
func RemoveEventDetailErr(f func(EventDetail) (bool, error), list []EventDetail) ([]EventDetail, error) {
	if f == nil {
		return []EventDetail{}, nil
	}
	var newList []EventDetail
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

func SomeEventDetail(f func(EventDetail) bool, list []EventDetail) bool {
	if f == nil {
		return false
	}
	for _, v := range list {
		if f(v) {
			return true
		}
	}
	return false
}

func SomeEventDetailPtr(f func(*EventDetail) bool, list []*EventDetail) bool {
	if f == nil {
		return false
	}
	for _, v := range list {
		if f(v) {
			return true
		}
	}
	return false
}

// SomeEventDetailPtrErr finds item in the list based on supplied function.
//
// Takes 2 input:
//	1. Function
//	2. List
//
// Returns:
//	(bool,err).
//	True if condition satisfies, else false
func SomeEventDetailPtrErr(f func(*EventDetail) (bool, error), list []*EventDetail) (bool, error) {
	if f == nil {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if r {
			return true, nil
		}
	}
	return false, nil
}

// SomeEventDetailErr finds item in the list based on supplied function.
//
// Takes 2 input:
//	1. Function
//	2. List
//
// Returns:
//	(bool,err).
//	True if condition satisfies, else false
func SomeEventDetailErr(f func(EventDetail) (bool, error), list []EventDetail) (bool, error) {
	if f == nil {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if r {
			return true, nil
		}
	}
	return false, nil
}

func EveryEventDetail(f func(EventDetail) bool, list []EventDetail) bool {
	if f == nil || len(list) == 0 {
		return false
	}
	for _, v := range list {
		if !f(v) {
			return false
		}
	}
	return true
}

func EveryEventDetailPtr(f func(*EventDetail) bool, list []*EventDetail) bool {
	if f == nil || len(list) == 0 {
		return false
	}
	for _, v := range list {
		if !f(v) {
			return false
		}
	}
	return true
}

// EveryEventDetailPtrErr returns true if supplied function returns logical true for every item in the list
func EveryEventDetailPtrErr(f func(*EventDetail) (bool, error), list []*EventDetail) (bool, error) {
	if f == nil || len(list) == 0 {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if !r {
			return false, nil
		}
	}
	return true, nil
}

// EveryEventDetailErr returns true if supplied function returns logical true for every item in the list
func EveryEventDetailErr(f func(EventDetail) (bool, error), list []EventDetail) (bool, error) {
	if f == nil || len(list) == 0 {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if !r {
			return false, nil
		}
	}
	return true, nil
}

func DropWhileEventDetail(f func(EventDetail) bool, list []EventDetail) []EventDetail {
	if f == nil {
		return []EventDetail{}
	}
	var newList []EventDetail
	for i, v := range list {
		if !f(v) {
			listLen := len(list)
			newList = make([]EventDetail, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList
		}
	}
	return newList
}

func DropWhileEventDetailPtr(f func(*EventDetail) bool, list []*EventDetail) []*EventDetail {
	if f == nil {
		return []*EventDetail{}
	}
	var newList []*EventDetail
	for i, v := range list {
		if !f(v) {
			listLen := len(list)
			newList = make([]*EventDetail, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList
		}
	}
	return newList
}

// DropWhileEventDetailPtrErr drops the items from the list as long as condition satisfies.
//
// Takes two inputs
//	1. Function: takes one input and returns (boolean, error)
//	2. list
//
// Returns:
// 	New List, error
//  Empty list if either one of arguments or both of them are nil
func DropWhileEventDetailPtrErr(f func(*EventDetail) (bool, error), list []*EventDetail) ([]*EventDetail, error) {
	if f == nil {
		return []*EventDetail{}, nil
	}
	var newList []*EventDetail
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			listLen := len(list)
			newList = make([]*EventDetail, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList, nil
		}
	}
	return newList, nil
}

// DropWhileEventDetailErr drops the items from the list as long as condition satisfies.
//
// Takes two inputs
//	1. Function: takes one input and returns (boolean, error)
//	2. list
//
// Returns:
// 	New List, error
//  Empty list if either one of arguments or both of them are nil
func DropWhileEventDetailErr(f func(EventDetail) (bool, error), list []EventDetail) ([]EventDetail, error) {
	if f == nil {
		return []EventDetail{}, nil
	}
	var newList []EventDetail
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			listLen := len(list)
			newList = make([]EventDetail, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList, nil
		}
	}
	return newList, nil
}

func TakeWhileEventDetail(f func(EventDetail) bool, list []EventDetail) []EventDetail {
	if f == nil {
		return []EventDetail{}
	}
	var newList []EventDetail
	for _, v := range list {
		if !f(v) {
			return newList
		}
		newList = append(newList, v)
	}
	return newList
}

func TakeWhileEventDetailPtr(f func(*EventDetail) bool, list []*EventDetail) []*EventDetail {
	if f == nil {
		return []*EventDetail{}
	}
	var newList []*EventDetail
	for _, v := range list {
		if !f(v) {
			return newList
		}
		newList = append(newList, v)
	}
	return newList
}

// TakeWhileEventDetailPtrErr returns new list based on condition in the supplied function. It returns new list once condition fails.
//
// Takes 2 inputs:
//	1. Function - 1 input of type *EventDetail and returns ([]*EventDetail, error)
//	2. List
//
// Returns:
//	New List, error.
//	Empty list if all the parameters are nil or either of one parameter is nil
func TakeWhileEventDetailPtrErr(f func(*EventDetail) (bool, error), list []*EventDetail) ([]*EventDetail, error) {
	if f == nil {
		return []*EventDetail{}, nil
	}
	var newList []*EventDetail
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			return newList, nil
		}
		newList = append(newList, v)
	}
	return newList, nil
}

// TakeWhileEventDetailErr returns new list based on condition in the supplied function. It returns new list once condition fails.
//
// Takes 2 inputs:
//	1. Function - 1 input of type EventDetail and returns ([]EventDetail, error)
//	2. List
//
// Returns:
//	New List, error.
//	Empty list if all the parameters are nil or either of one parameter is nil
func TakeWhileEventDetailErr(f func(EventDetail) (bool, error), list []EventDetail) ([]EventDetail, error) {
	if f == nil {
		return []EventDetail{}, nil
	}
	var newList []EventDetail
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			return newList, nil
		}
		newList = append(newList, v)
	}
	return newList, nil
}

func PMapEventDetail(f func(EventDetail) EventDetail, list []EventDetail) []EventDetail {
	if f == nil {
		return []EventDetail{}
	}

	ch := make(chan map[int]EventDetail)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]EventDetail, i int, v EventDetail) {
			defer wg.Done()
			ch <- map[int]EventDetail{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]EventDetail, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapEventDetailPtr applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
func PMapEventDetailPtr(f func(*EventDetail) *EventDetail, list []*EventDetail) []*EventDetail {
	if f == nil {
		return []*EventDetail{}
	}

	ch := make(chan map[int]*EventDetail)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*EventDetail, i int, v *EventDetail) {
			defer wg.Done()
			ch <- map[int]*EventDetail{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]*EventDetail, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapEventDetailPtrErr applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
func PMapEventDetailPtrErr(f func(*EventDetail) (*EventDetail, error), list []*EventDetail) ([]*EventDetail, error) {
	if f == nil {
		return []*EventDetail{}, nil
	}

	ch := make(chan map[int]*EventDetail, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*EventDetail, i int, v *EventDetail) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]*EventDetail{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)

	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]*EventDetail, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// PMapEventDetailErr applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
func PMapEventDetailErr(f func(EventDetail) (EventDetail, error), list []EventDetail) ([]EventDetail, error) {
	if f == nil {
		return []EventDetail{}, nil
	}

	ch := make(chan map[int]EventDetail, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]EventDetail, i int, v EventDetail) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]EventDetail{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)

	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]EventDetail, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

func FilterMapEventDetail(fFilter func(EventDetail) bool, fMap func(EventDetail) EventDetail, list []EventDetail) []EventDetail {
	if fFilter == nil || fMap == nil {
		return []EventDetail{}
	}
	var newList []EventDetail
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

func FilterMapEventDetailPtr(fFilter func(*EventDetail) bool, fMap func(*EventDetail) *EventDetail, list []*EventDetail) []*EventDetail {
	if fFilter == nil || fMap == nil {
		return []*EventDetail{}
	}
	var newList []*EventDetail
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapEventDetailPtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input(*EventDetail) and returns (bool, error).
//	2. Function: takes *EventDetail as argument and returns (*EventDetail, error)
// 	3. Slice of type []*EventDetail
//
// Returns:
//	New List ([]*EventDetail, error).
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEventDetailPtrErr(fFilter func(*EventDetail) (bool, error), fMap func(*EventDetail) (*EventDetail, error), list []*EventDetail) ([]*EventDetail, error) {
	if fFilter == nil || fMap == nil {
		return []*EventDetail{}, nil
	}
	var newList []*EventDetail
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapEventDetailErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input(EventDetail) and returns (bool, error).
//	2. Function: takes EventDetail as argument and returns (EventDetail, error)
// 	3. Slice of type []EventDetail
//
// Returns:
//	New List ([]EventDetail, error).
//  Empty list if all there parameters are nil or either of parameter is nil
//
func FilterMapEventDetailErr(fFilter func(EventDetail) (bool, error), fMap func(EventDetail) (EventDetail, error), list []EventDetail) ([]EventDetail, error) {
	if fFilter == nil || fMap == nil {
		return []EventDetail{}, nil
	}
	var newList []EventDetail
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

func RestEventDetail(l []EventDetail) []EventDetail {
	if l == nil {
		return []EventDetail{}
	}

	len := len(l)
	if len == 0 || len == 1 {
		return []EventDetail{}
	}

	newList := make([]EventDetail, len-1)

	for i, v := range l[1:] {
		newList[i] = v
	}

	return newList
}


// RestEventDetail removes 1st item of the list and return new list having rest of the items
func RestEventDetailPtr(l []*EventDetail) []*EventDetail {
	if l == nil {
		return []*EventDetail{}
	}

	len := len(l)
	if len == 0 || len == 1 {
		return []*EventDetail{}
	}

	newList := make([]*EventDetail, len-1)

	for i, v := range l[1:] {
		newList[i] = v
	}

	return newList
}

func ReduceEventDetail(f func(EventDetail, EventDetail) EventDetail, list []EventDetail, initializer ...EventDetail) EventDetail {
	var init EventDetail 
	lenList := len(list)

	if initializer != nil {
		init = initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0]
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}
	
	if lenList == 0 {
		return init
	}
	r := f(init, list[0])
	return ReduceEventDetail(f, list[1:], r)
}

func ReduceEventDetailPtr(f func(*EventDetail, *EventDetail) *EventDetail, list []*EventDetail, initializer ...EventDetail) *EventDetail {
	var initVal EventDetail
	var init *EventDetail = &initVal
	lenList := len(list)

	if initializer != nil {
		init = &initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0]
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init
	}

	r := f(init, list[0])
	return ReduceEventDetailPtr(f, list[1:], *r)
}

// ReduceEventDetailPtrErr reduces a list to a single value by combining elements via a supplied function
//
// Takes three inputs
//	A. function - takes two arguments (*EventDetail, *EventDetail)
//	B. list of type []*EventDetail
// 	C. initializer (optional of type EventDetail)
//
// Returns:
//	single value, error: (*EventDetail, error)
func ReduceEventDetailPtrErr(f func(*EventDetail, *EventDetail) (*EventDetail, error), list []*EventDetail, initializer ...EventDetail) (*EventDetail, error) {
	var initVal EventDetail
	var init *EventDetail = &initVal
	lenList := len(list)

	if initializer != nil {
		init = &initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0], nil
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init, nil
	}

	r, err := f(init, list[0])
	if err != nil {
		return nil, err
	}
	return ReduceEventDetailPtrErr(f, list[1:], *r)
}

// ReduceEventDetailErr reduces a list to a single value by combining elements via a supplied function
//
// Takes three inputs
//	A. function - takes two arguments (EventDetail, EventDetail)
//	B. list of type []EventDetail
// 	C. initializer (optional of type EventDetail)
//
// Returns:
//	single value, error: (EventDetail, error)
func ReduceEventDetailErr(f func(EventDetail, EventDetail) (EventDetail, error), list []EventDetail, initializer ...EventDetail) (EventDetail, error) {
	var initVal EventDetail
	var init EventDetail = initVal
	lenList := len(list)

	if initializer != nil {
		init = initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0], nil
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init, nil
	}

	r, err := f(init, list[0])
	if err != nil {
		return r, err
	}
	return ReduceEventDetailErr(f, list[1:], r)
}

// DropLastEventDetail drops last item from the list and returns new list.
// Returns empty list if there is only one item in the list or list empty
func DropLastEventDetail(list []EventDetail) []EventDetail {
	listLen := len(list)

	if list == nil || listLen == 0 || listLen == 1 {
		return []EventDetail{}
	}

	newList := make([]EventDetail, listLen-1)

	for i := 0; i < listLen-1; i++ {
		newList[i] = list[i]
	}
	return newList
}

// DropLastEventDetailPtr drops last item from the list and returns new list.
// Returns empty list if there is only one item in the list or list empty
func DropLastEventDetailPtr(list []*EventDetail) []*EventDetail {
	listLen := len(list)

	if list == nil || listLen == 0 || listLen == 1 {
		return []*EventDetail{}
	}

	newList := make([]*EventDetail, listLen-1)

	for i := 0; i < listLen-1; i++ {
		newList[i] = list[i]
	}
	return newList
}

// ReverseEventDetails reverse the list
func ReverseEventDetails(list []EventDetail) []EventDetail {
	newList := make([]EventDetail, len(list))
	for i := 0; i < len(list); i++ {
		newList[i] = list[len(list)-(i+1)]
	}
	return newList
}

// ReverseEventDetailsPtr reverse the list
func ReverseEventDetailsPtr(list []*EventDetail) []*EventDetail {
	newList := make([]*EventDetail, len(list))
	for i := 0; i < len(list); i++ {
		newList[i] = list[len(list)-(i+1)]
	}
	return newList
}

// TakeEventDetail returns n items in the list
func TakeEventDetail(n int, list []EventDetail) []EventDetail {
	if n < 0 {
		return []EventDetail{}
	}

	newListLen := len(list)

	if n < newListLen {
		newListLen = n
	}
	newList := make([]EventDetail, newListLen)
	for i := 0; i < newListLen; i++ {
		newList[i] = list[i]
	}
	return newList
}

// TakeEventDetailPtr returns n items in the list
func TakeEventDetailPtr(n int, list []*EventDetail) []*EventDetail {
	if n < 0 {
		return []*EventDetail{}
	}

	newListLen := len(list)

	if n < newListLen {
		newListLen = n
	}
	newList := make([]*EventDetail, newListLen)
	for i := 0; i < newListLen; i++ {
		newList[i] = list[i]
	}
	return newList
}



// MergeEventDetail takes two inputs: map[EventDetail]EventDetail and map[EventDetail]EventDetail and merge two maps and returns a new map[EventDetail]EventDetail.
func MergeEventDetail(map1, map2 map[EventDetail]EventDetail) map[EventDetail]EventDetail {
	if map1 == nil && map2 == nil {
		return map[EventDetail]EventDetail{}
	}

	newMap := make(map[EventDetail]EventDetail)

	if map1 == nil {
		for k, v := range map2 {
			newMap[k] = v
		}
		return newMap
	}

	if map2 == nil {
		for k, v := range map1 {
			newMap[k] = v
		}
		return newMap
	}

	for k, v := range map1 {
		newMap[k] = v
	}

	for k, v := range map2 {
		newMap[k] = v
	}

	return newMap
}

// ZipEventDetail takes two inputs: first list of type: []EventDetail, second list of type: []EventDetail.
// Then it merges two list and returns a new map of type: map[EventDetail]EventDetail
func ZipEventDetail(list1 []EventDetail, list2 []EventDetail) map[EventDetail]EventDetail {
	newMap := make(map[EventDetail]EventDetail)

	len1 := len(list1)
	len2 := len(list2)

	if len1 == 0 || len2 == 0 {
		return newMap
	}

	minLen := len1
	if len2 < minLen {
		minLen = len2
	}

	for i := 0; i < minLen; i++ {
		newMap[list1[i]] = list2[i]
	}

	return newMap
}

type byDayEventDetail []EventDetail

func (a byDayEventDetail) Len() int           { return len(a) }
func (a byDayEventDetail) Less(i, j int) bool { return a[i].Day < a[j].Day }
func (a byDayEventDetail) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortEventDetailByDay sort structs
func SortEventDetailByDay(list []EventDetail) []EventDetail {
	if len(list) == 0 {
		return []EventDetail{}
	}
	newList := make([]EventDetail, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byDayEventDetail(newList))
	return newList
}

// SortEventDetailByDayPtr sorts structs
func SortEventDetailByDayPtr(list []*EventDetail) []*EventDetail {
	if len(list) == 0 {
		return []*EventDetail{}
	}
	newList := make([]EventDetail, len(list))
	newListPtr := make([]*EventDetail, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byDayEventDetail(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byDayEventDetailDesc []EventDetail

func (a byDayEventDetailDesc) Len() int           { return len(a) }
func (a byDayEventDetailDesc) Less(i, j int) bool { return a[i].Day > a[j].Day }
func (a byDayEventDetailDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortEventDetailByDayDesc sorts structs
func SortEventDetailByDayDesc(list []EventDetail) []EventDetail {
	if len(list) == 0 {
		return []EventDetail{}
	}
	newList := make([]EventDetail, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byDayEventDetailDesc(newList))
	return newList
}

// SortEventDetailByDayDescPtr sorts structs
func SortEventDetailByDayDescPtr(list []*EventDetail) []*EventDetail {
	if len(list) == 0 {
		return []*EventDetail{}
	}
	newList := make([]EventDetail, len(list))
	newListPtr := make([]*EventDetail, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byDayEventDetailDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byMonthEventDetail []EventDetail

func (a byMonthEventDetail) Len() int           { return len(a) }
func (a byMonthEventDetail) Less(i, j int) bool { return a[i].Month < a[j].Month }
func (a byMonthEventDetail) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortEventDetailByMonth sort structs
func SortEventDetailByMonth(list []EventDetail) []EventDetail {
	if len(list) == 0 {
		return []EventDetail{}
	}
	newList := make([]EventDetail, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byMonthEventDetail(newList))
	return newList
}

// SortEventDetailByMonthPtr sorts structs
func SortEventDetailByMonthPtr(list []*EventDetail) []*EventDetail {
	if len(list) == 0 {
		return []*EventDetail{}
	}
	newList := make([]EventDetail, len(list))
	newListPtr := make([]*EventDetail, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byMonthEventDetail(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byMonthEventDetailDesc []EventDetail

func (a byMonthEventDetailDesc) Len() int           { return len(a) }
func (a byMonthEventDetailDesc) Less(i, j int) bool { return a[i].Month > a[j].Month }
func (a byMonthEventDetailDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortEventDetailByMonthDesc sorts structs
func SortEventDetailByMonthDesc(list []EventDetail) []EventDetail {
	if len(list) == 0 {
		return []EventDetail{}
	}
	newList := make([]EventDetail, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byMonthEventDetailDesc(newList))
	return newList
}

// SortEventDetailByMonthDescPtr sorts structs
func SortEventDetailByMonthDescPtr(list []*EventDetail) []*EventDetail {
	if len(list) == 0 {
		return []*EventDetail{}
	}
	newList := make([]EventDetail, len(list))
	newListPtr := make([]*EventDetail, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byMonthEventDetailDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byYearEventDetail []EventDetail

func (a byYearEventDetail) Len() int           { return len(a) }
func (a byYearEventDetail) Less(i, j int) bool { return a[i].Year < a[j].Year }
func (a byYearEventDetail) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortEventDetailByYear sort structs
func SortEventDetailByYear(list []EventDetail) []EventDetail {
	if len(list) == 0 {
		return []EventDetail{}
	}
	newList := make([]EventDetail, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byYearEventDetail(newList))
	return newList
}

// SortEventDetailByYearPtr sorts structs
func SortEventDetailByYearPtr(list []*EventDetail) []*EventDetail {
	if len(list) == 0 {
		return []*EventDetail{}
	}
	newList := make([]EventDetail, len(list))
	newListPtr := make([]*EventDetail, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byYearEventDetail(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byYearEventDetailDesc []EventDetail

func (a byYearEventDetailDesc) Len() int           { return len(a) }
func (a byYearEventDetailDesc) Less(i, j int) bool { return a[i].Year > a[j].Year }
func (a byYearEventDetailDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortEventDetailByYearDesc sorts structs
func SortEventDetailByYearDesc(list []EventDetail) []EventDetail {
	if len(list) == 0 {
		return []EventDetail{}
	}
	newList := make([]EventDetail, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byYearEventDetailDesc(newList))
	return newList
}

// SortEventDetailByYearDescPtr sorts structs
func SortEventDetailByYearDescPtr(list []*EventDetail) []*EventDetail {
	if len(list) == 0 {
		return []*EventDetail{}
	}
	newList := make([]EventDetail, len(list))
	newListPtr := make([]*EventDetail, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byYearEventDetailDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byTitleEventDetail []EventDetail

func (a byTitleEventDetail) Len() int           { return len(a) }
func (a byTitleEventDetail) Less(i, j int) bool { return a[i].Title < a[j].Title }
func (a byTitleEventDetail) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortEventDetailByTitle sort structs
func SortEventDetailByTitle(list []EventDetail) []EventDetail {
	if len(list) == 0 {
		return []EventDetail{}
	}
	newList := make([]EventDetail, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byTitleEventDetail(newList))
	return newList
}

// SortEventDetailByTitlePtr sorts structs
func SortEventDetailByTitlePtr(list []*EventDetail) []*EventDetail {
	if len(list) == 0 {
		return []*EventDetail{}
	}
	newList := make([]EventDetail, len(list))
	newListPtr := make([]*EventDetail, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byTitleEventDetail(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byTitleEventDetailDesc []EventDetail

func (a byTitleEventDetailDesc) Len() int           { return len(a) }
func (a byTitleEventDetailDesc) Less(i, j int) bool { return a[i].Title > a[j].Title }
func (a byTitleEventDetailDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortEventDetailByTitleDesc sorts structs
func SortEventDetailByTitleDesc(list []EventDetail) []EventDetail {
	if len(list) == 0 {
		return []EventDetail{}
	}
	newList := make([]EventDetail, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byTitleEventDetailDesc(newList))
	return newList
}

// SortEventDetailByTitleDescPtr sorts structs
func SortEventDetailByTitleDescPtr(list []*EventDetail) []*EventDetail {
	if len(list) == 0 {
		return []*EventDetail{}
	}
	newList := make([]EventDetail, len(list))
	newListPtr := make([]*EventDetail, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byTitleEventDetailDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byInfoEventDetail []EventDetail

func (a byInfoEventDetail) Len() int           { return len(a) }
func (a byInfoEventDetail) Less(i, j int) bool { return a[i].Info < a[j].Info }
func (a byInfoEventDetail) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortEventDetailByInfo sort structs
func SortEventDetailByInfo(list []EventDetail) []EventDetail {
	if len(list) == 0 {
		return []EventDetail{}
	}
	newList := make([]EventDetail, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byInfoEventDetail(newList))
	return newList
}

// SortEventDetailByInfoPtr sorts structs
func SortEventDetailByInfoPtr(list []*EventDetail) []*EventDetail {
	if len(list) == 0 {
		return []*EventDetail{}
	}
	newList := make([]EventDetail, len(list))
	newListPtr := make([]*EventDetail, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byInfoEventDetail(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byInfoEventDetailDesc []EventDetail

func (a byInfoEventDetailDesc) Len() int           { return len(a) }
func (a byInfoEventDetailDesc) Less(i, j int) bool { return a[i].Info > a[j].Info }
func (a byInfoEventDetailDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortEventDetailByInfoDesc sorts structs
func SortEventDetailByInfoDesc(list []EventDetail) []EventDetail {
	if len(list) == 0 {
		return []EventDetail{}
	}
	newList := make([]EventDetail, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byInfoEventDetailDesc(newList))
	return newList
}

// SortEventDetailByInfoDescPtr sorts structs
func SortEventDetailByInfoDescPtr(list []*EventDetail) []*EventDetail {
	if len(list) == 0 {
		return []*EventDetail{}
	}
	newList := make([]EventDetail, len(list))
	newListPtr := make([]*EventDetail, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byInfoEventDetailDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byURLEventDetail []EventDetail

func (a byURLEventDetail) Len() int           { return len(a) }
func (a byURLEventDetail) Less(i, j int) bool { return a[i].URL < a[j].URL }
func (a byURLEventDetail) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortEventDetailByURL sort structs
func SortEventDetailByURL(list []EventDetail) []EventDetail {
	if len(list) == 0 {
		return []EventDetail{}
	}
	newList := make([]EventDetail, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byURLEventDetail(newList))
	return newList
}

// SortEventDetailByURLPtr sorts structs
func SortEventDetailByURLPtr(list []*EventDetail) []*EventDetail {
	if len(list) == 0 {
		return []*EventDetail{}
	}
	newList := make([]EventDetail, len(list))
	newListPtr := make([]*EventDetail, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byURLEventDetail(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byURLEventDetailDesc []EventDetail

func (a byURLEventDetailDesc) Len() int           { return len(a) }
func (a byURLEventDetailDesc) Less(i, j int) bool { return a[i].URL > a[j].URL }
func (a byURLEventDetailDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortEventDetailByURLDesc sorts structs
func SortEventDetailByURLDesc(list []EventDetail) []EventDetail {
	if len(list) == 0 {
		return []EventDetail{}
	}
	newList := make([]EventDetail, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byURLEventDetailDesc(newList))
	return newList
}

// SortEventDetailByURLDescPtr sorts structs
func SortEventDetailByURLDescPtr(list []*EventDetail) []*EventDetail {
	if len(list) == 0 {
		return []*EventDetail{}
	}
	newList := make([]EventDetail, len(list))
	newListPtr := make([]*EventDetail, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byURLEventDetailDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byTypeEventDetail []EventDetail

func (a byTypeEventDetail) Len() int           { return len(a) }
func (a byTypeEventDetail) Less(i, j int) bool { return a[i].Type < a[j].Type }
func (a byTypeEventDetail) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortEventDetailByType sort structs
func SortEventDetailByType(list []EventDetail) []EventDetail {
	if len(list) == 0 {
		return []EventDetail{}
	}
	newList := make([]EventDetail, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byTypeEventDetail(newList))
	return newList
}

// SortEventDetailByTypePtr sorts structs
func SortEventDetailByTypePtr(list []*EventDetail) []*EventDetail {
	if len(list) == 0 {
		return []*EventDetail{}
	}
	newList := make([]EventDetail, len(list))
	newListPtr := make([]*EventDetail, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byTypeEventDetail(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byTypeEventDetailDesc []EventDetail

func (a byTypeEventDetailDesc) Len() int           { return len(a) }
func (a byTypeEventDetailDesc) Less(i, j int) bool { return a[i].Type > a[j].Type }
func (a byTypeEventDetailDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortEventDetailByTypeDesc sorts structs
func SortEventDetailByTypeDesc(list []EventDetail) []EventDetail {
	if len(list) == 0 {
		return []EventDetail{}
	}
	newList := make([]EventDetail, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byTypeEventDetailDesc(newList))
	return newList
}

// SortEventDetailByTypeDescPtr sorts structs
func SortEventDetailByTypeDescPtr(list []*EventDetail) []*EventDetail {
	if len(list) == 0 {
		return []*EventDetail{}
	}
	newList := make([]EventDetail, len(list))
	newListPtr := make([]*EventDetail, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byTypeEventDetailDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byCreationDateEventDetail []EventDetail

func (a byCreationDateEventDetail) Len() int           { return len(a) }
func (a byCreationDateEventDetail) Less(i, j int) bool { return a[i].CreationDate.Before(a[j].CreationDate) }
func (a byCreationDateEventDetail) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortEventDetailByCreationDate sort structs
func SortEventDetailByCreationDate(list []EventDetail) []EventDetail {
	if len(list) == 0 {
		return []EventDetail{}
	}
	newList := make([]EventDetail, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byCreationDateEventDetail(newList))
	return newList
}

// SortEventDetailByCreationDatePtr sorts structs
func SortEventDetailByCreationDatePtr(list []*EventDetail) []*EventDetail {
	if len(list) == 0 {
		return []*EventDetail{}
	}
	newList := make([]EventDetail, len(list))
	newListPtr := make([]*EventDetail, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byCreationDateEventDetail(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byCreationDateEventDetailDesc []EventDetail

func (a byCreationDateEventDetailDesc) Len() int           { return len(a) }
func (a byCreationDateEventDetailDesc) Less(i, j int) bool { return a[i].CreationDate.After(a[j].CreationDate) }
func (a byCreationDateEventDetailDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortEventDetailByCreationDateDesc sorts structs
func SortEventDetailByCreationDateDesc(list []EventDetail) []EventDetail {
	if len(list) == 0 {
		return []EventDetail{}
	}
	newList := make([]EventDetail, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byCreationDateEventDetailDesc(newList))
	return newList
}

// SortEventDetailByCreationDateDescPtr sorts structs
func SortEventDetailByCreationDateDescPtr(list []*EventDetail) []*EventDetail {
	if len(list) == 0 {
		return []*EventDetail{}
	}
	newList := make([]EventDetail, len(list))
	newListPtr := make([]*EventDetail, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byCreationDateEventDetailDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
// UnionEventDetailByDay return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionEventDetailByDay(arrList ...[]EventDetail) []EventDetail {
	resultMap := make(map[int]bool)
	var resultArr []EventDetail
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Day]
			if !ok {
				resultMap[v.Day] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionEventDetailByDayPtr(arrList ...[]*EventDetail) []*EventDetail {
	resultMap := make(map[int]bool)
	var resultArr []*EventDetail
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Day]
			if !ok {
				resultMap[v.Day] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionEventDetailByDay return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionEventDetailByDay(arrList ...[]EventDetail) []EventDetail {
	if arrList == nil {
		return []EventDetail{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []EventDetail
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Day]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Day] = true
			}
		}
		return newList
	}

	var newList []EventDetail
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Day == v.Day {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Day]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Day] = true
			}
		}
	}
	return newList
}

// IntersectionEventDetailByDayPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionEventDetailByDayPtr(arrList ...[]*EventDetail) []*EventDetail {
	if arrList == nil {
		return []*EventDetail{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*EventDetail
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Day]
			if !ok {
				resultMap[arrList[0][i].Day] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*EventDetail
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Day == v.Day {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Day]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Day] = true
			}
		}
	}
	return newList
}

// DifferenceEventDetailByDay returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceEventDetailByDay(arrList ...[]EventDetail) []EventDetail {
	if arrList == nil {
		return []EventDetail{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []EventDetail
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Day]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Day] = true
			}
		}
		return newList
	}

	var newList []EventDetail
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Day == v.Day {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Day]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Day] = true
			}
		}
	}
	return newList
}

// DifferenceEventDetailByDayPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceEventDetailByDayPtr(arrList ...[]*EventDetail) []*EventDetail {
	if arrList == nil {
		return []*EventDetail{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*EventDetail
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Day]
			if !ok {
				resultMap[arrList[0][i].Day] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*EventDetail
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Day == v.Day {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Day]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Day] = true
			}
		}
	}
	return newList
}

// SubsetEventDetailByDay returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetEventDetailByDay(list1, list2 []EventDetail) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Day]
		if !ok {
			found := false
			resultMap[list1[i].Day] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Day == list2[j].Day {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetEventDetailByDayPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetEventDetailByDayPtr(list1, list2 []*EventDetail) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Day]
		if !ok {
			found := false
			resultMap[list1[i].Day] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Day == list2[j].Day {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetEventDetailByDay returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetEventDetailByDay(list1, list2 []EventDetail) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Day]
		if !ok {
			found := false
			resultMap[list2[i].Day] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Day == list1[j].Day {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetEventDetailByDayPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetEventDetailByDayPtr(list1, list2 []*EventDetail) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Day]
		if !ok {
			found := false
			resultMap[list2[i].Day] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Day == list1[j].Day {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetEventDetailByDay returns a set of the distinct elements of coll.
func SetEventDetailByDay(list []EventDetail) []EventDetail {
	if list == nil || len(list) == 0 {
		return []EventDetail{}
	}

	resultMap := make(map[int]bool)
	newList := []EventDetail{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Day]
		if !ok {
			resultMap[list[i].Day] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetEventDetailByDayPtr returns a set of the distinct elements of coll.
func SetEventDetailByDayPtr(list []*EventDetail) []*EventDetail {
	if list == nil || len(list) == 0 {
		return []*EventDetail{}
	}

	resultMap := make(map[int]bool)
	newList := []*EventDetail{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Day]
		if !ok {
			resultMap[list[i].Day] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionEventDetailByMonth return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionEventDetailByMonth(arrList ...[]EventDetail) []EventDetail {
	resultMap := make(map[int]bool)
	var resultArr []EventDetail
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Month]
			if !ok {
				resultMap[v.Month] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionEventDetailByMonthPtr(arrList ...[]*EventDetail) []*EventDetail {
	resultMap := make(map[int]bool)
	var resultArr []*EventDetail
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Month]
			if !ok {
				resultMap[v.Month] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionEventDetailByMonth return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionEventDetailByMonth(arrList ...[]EventDetail) []EventDetail {
	if arrList == nil {
		return []EventDetail{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []EventDetail
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Month]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Month] = true
			}
		}
		return newList
	}

	var newList []EventDetail
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Month == v.Month {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Month]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Month] = true
			}
		}
	}
	return newList
}

// IntersectionEventDetailByMonthPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionEventDetailByMonthPtr(arrList ...[]*EventDetail) []*EventDetail {
	if arrList == nil {
		return []*EventDetail{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*EventDetail
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Month]
			if !ok {
				resultMap[arrList[0][i].Month] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*EventDetail
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Month == v.Month {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Month]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Month] = true
			}
		}
	}
	return newList
}

// DifferenceEventDetailByMonth returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceEventDetailByMonth(arrList ...[]EventDetail) []EventDetail {
	if arrList == nil {
		return []EventDetail{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []EventDetail
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Month]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Month] = true
			}
		}
		return newList
	}

	var newList []EventDetail
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Month == v.Month {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Month]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Month] = true
			}
		}
	}
	return newList
}

// DifferenceEventDetailByMonthPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceEventDetailByMonthPtr(arrList ...[]*EventDetail) []*EventDetail {
	if arrList == nil {
		return []*EventDetail{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*EventDetail
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Month]
			if !ok {
				resultMap[arrList[0][i].Month] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*EventDetail
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Month == v.Month {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Month]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Month] = true
			}
		}
	}
	return newList
}

// SubsetEventDetailByMonth returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetEventDetailByMonth(list1, list2 []EventDetail) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Month]
		if !ok {
			found := false
			resultMap[list1[i].Month] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Month == list2[j].Month {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetEventDetailByMonthPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetEventDetailByMonthPtr(list1, list2 []*EventDetail) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Month]
		if !ok {
			found := false
			resultMap[list1[i].Month] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Month == list2[j].Month {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetEventDetailByMonth returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetEventDetailByMonth(list1, list2 []EventDetail) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Month]
		if !ok {
			found := false
			resultMap[list2[i].Month] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Month == list1[j].Month {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetEventDetailByMonthPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetEventDetailByMonthPtr(list1, list2 []*EventDetail) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Month]
		if !ok {
			found := false
			resultMap[list2[i].Month] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Month == list1[j].Month {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetEventDetailByMonth returns a set of the distinct elements of coll.
func SetEventDetailByMonth(list []EventDetail) []EventDetail {
	if list == nil || len(list) == 0 {
		return []EventDetail{}
	}

	resultMap := make(map[int]bool)
	newList := []EventDetail{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Month]
		if !ok {
			resultMap[list[i].Month] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetEventDetailByMonthPtr returns a set of the distinct elements of coll.
func SetEventDetailByMonthPtr(list []*EventDetail) []*EventDetail {
	if list == nil || len(list) == 0 {
		return []*EventDetail{}
	}

	resultMap := make(map[int]bool)
	newList := []*EventDetail{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Month]
		if !ok {
			resultMap[list[i].Month] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionEventDetailByYear return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionEventDetailByYear(arrList ...[]EventDetail) []EventDetail {
	resultMap := make(map[int]bool)
	var resultArr []EventDetail
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Year]
			if !ok {
				resultMap[v.Year] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionEventDetailByYearPtr(arrList ...[]*EventDetail) []*EventDetail {
	resultMap := make(map[int]bool)
	var resultArr []*EventDetail
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Year]
			if !ok {
				resultMap[v.Year] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionEventDetailByYear return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionEventDetailByYear(arrList ...[]EventDetail) []EventDetail {
	if arrList == nil {
		return []EventDetail{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []EventDetail
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Year]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Year] = true
			}
		}
		return newList
	}

	var newList []EventDetail
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Year == v.Year {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Year]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Year] = true
			}
		}
	}
	return newList
}

// IntersectionEventDetailByYearPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionEventDetailByYearPtr(arrList ...[]*EventDetail) []*EventDetail {
	if arrList == nil {
		return []*EventDetail{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*EventDetail
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Year]
			if !ok {
				resultMap[arrList[0][i].Year] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*EventDetail
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Year == v.Year {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Year]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Year] = true
			}
		}
	}
	return newList
}

// DifferenceEventDetailByYear returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceEventDetailByYear(arrList ...[]EventDetail) []EventDetail {
	if arrList == nil {
		return []EventDetail{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []EventDetail
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Year]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Year] = true
			}
		}
		return newList
	}

	var newList []EventDetail
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Year == v.Year {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Year]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Year] = true
			}
		}
	}
	return newList
}

// DifferenceEventDetailByYearPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceEventDetailByYearPtr(arrList ...[]*EventDetail) []*EventDetail {
	if arrList == nil {
		return []*EventDetail{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*EventDetail
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Year]
			if !ok {
				resultMap[arrList[0][i].Year] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*EventDetail
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Year == v.Year {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Year]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Year] = true
			}
		}
	}
	return newList
}

// SubsetEventDetailByYear returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetEventDetailByYear(list1, list2 []EventDetail) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Year]
		if !ok {
			found := false
			resultMap[list1[i].Year] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Year == list2[j].Year {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetEventDetailByYearPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetEventDetailByYearPtr(list1, list2 []*EventDetail) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Year]
		if !ok {
			found := false
			resultMap[list1[i].Year] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Year == list2[j].Year {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetEventDetailByYear returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetEventDetailByYear(list1, list2 []EventDetail) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Year]
		if !ok {
			found := false
			resultMap[list2[i].Year] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Year == list1[j].Year {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetEventDetailByYearPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetEventDetailByYearPtr(list1, list2 []*EventDetail) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Year]
		if !ok {
			found := false
			resultMap[list2[i].Year] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Year == list1[j].Year {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetEventDetailByYear returns a set of the distinct elements of coll.
func SetEventDetailByYear(list []EventDetail) []EventDetail {
	if list == nil || len(list) == 0 {
		return []EventDetail{}
	}

	resultMap := make(map[int]bool)
	newList := []EventDetail{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Year]
		if !ok {
			resultMap[list[i].Year] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetEventDetailByYearPtr returns a set of the distinct elements of coll.
func SetEventDetailByYearPtr(list []*EventDetail) []*EventDetail {
	if list == nil || len(list) == 0 {
		return []*EventDetail{}
	}

	resultMap := make(map[int]bool)
	newList := []*EventDetail{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Year]
		if !ok {
			resultMap[list[i].Year] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionEventDetailByTitle return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionEventDetailByTitle(arrList ...[]EventDetail) []EventDetail {
	resultMap := make(map[string]bool)
	var resultArr []EventDetail
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Title]
			if !ok {
				resultMap[v.Title] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionEventDetailByTitlePtr(arrList ...[]*EventDetail) []*EventDetail {
	resultMap := make(map[string]bool)
	var resultArr []*EventDetail
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Title]
			if !ok {
				resultMap[v.Title] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionEventDetailByTitle return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionEventDetailByTitle(arrList ...[]EventDetail) []EventDetail {
	if arrList == nil {
		return []EventDetail{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []EventDetail
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Title]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Title] = true
			}
		}
		return newList
	}

	var newList []EventDetail
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Title == v.Title {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Title]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Title] = true
			}
		}
	}
	return newList
}

// IntersectionEventDetailByTitlePtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionEventDetailByTitlePtr(arrList ...[]*EventDetail) []*EventDetail {
	if arrList == nil {
		return []*EventDetail{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*EventDetail
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Title]
			if !ok {
				resultMap[arrList[0][i].Title] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*EventDetail
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Title == v.Title {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Title]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Title] = true
			}
		}
	}
	return newList
}

// DifferenceEventDetailByTitle returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceEventDetailByTitle(arrList ...[]EventDetail) []EventDetail {
	if arrList == nil {
		return []EventDetail{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []EventDetail
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Title]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Title] = true
			}
		}
		return newList
	}

	var newList []EventDetail
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Title == v.Title {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Title]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Title] = true
			}
		}
	}
	return newList
}

// DifferenceEventDetailByTitlePtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceEventDetailByTitlePtr(arrList ...[]*EventDetail) []*EventDetail {
	if arrList == nil {
		return []*EventDetail{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*EventDetail
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Title]
			if !ok {
				resultMap[arrList[0][i].Title] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*EventDetail
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Title == v.Title {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Title]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Title] = true
			}
		}
	}
	return newList
}

// SubsetEventDetailByTitle returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetEventDetailByTitle(list1, list2 []EventDetail) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Title]
		if !ok {
			found := false
			resultMap[list1[i].Title] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Title == list2[j].Title {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetEventDetailByTitlePtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetEventDetailByTitlePtr(list1, list2 []*EventDetail) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Title]
		if !ok {
			found := false
			resultMap[list1[i].Title] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Title == list2[j].Title {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetEventDetailByTitle returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetEventDetailByTitle(list1, list2 []EventDetail) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Title]
		if !ok {
			found := false
			resultMap[list2[i].Title] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Title == list1[j].Title {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetEventDetailByTitlePtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetEventDetailByTitlePtr(list1, list2 []*EventDetail) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Title]
		if !ok {
			found := false
			resultMap[list2[i].Title] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Title == list1[j].Title {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetEventDetailByTitle returns a set of the distinct elements of coll.
func SetEventDetailByTitle(list []EventDetail) []EventDetail {
	if list == nil || len(list) == 0 {
		return []EventDetail{}
	}

	resultMap := make(map[string]bool)
	newList := []EventDetail{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Title]
		if !ok {
			resultMap[list[i].Title] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetEventDetailByTitlePtr returns a set of the distinct elements of coll.
func SetEventDetailByTitlePtr(list []*EventDetail) []*EventDetail {
	if list == nil || len(list) == 0 {
		return []*EventDetail{}
	}

	resultMap := make(map[string]bool)
	newList := []*EventDetail{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Title]
		if !ok {
			resultMap[list[i].Title] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionEventDetailByInfo return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionEventDetailByInfo(arrList ...[]EventDetail) []EventDetail {
	resultMap := make(map[string]bool)
	var resultArr []EventDetail
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Info]
			if !ok {
				resultMap[v.Info] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionEventDetailByInfoPtr(arrList ...[]*EventDetail) []*EventDetail {
	resultMap := make(map[string]bool)
	var resultArr []*EventDetail
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Info]
			if !ok {
				resultMap[v.Info] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionEventDetailByInfo return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionEventDetailByInfo(arrList ...[]EventDetail) []EventDetail {
	if arrList == nil {
		return []EventDetail{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []EventDetail
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Info]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Info] = true
			}
		}
		return newList
	}

	var newList []EventDetail
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Info == v.Info {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Info]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Info] = true
			}
		}
	}
	return newList
}

// IntersectionEventDetailByInfoPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionEventDetailByInfoPtr(arrList ...[]*EventDetail) []*EventDetail {
	if arrList == nil {
		return []*EventDetail{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*EventDetail
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Info]
			if !ok {
				resultMap[arrList[0][i].Info] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*EventDetail
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Info == v.Info {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Info]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Info] = true
			}
		}
	}
	return newList
}

// DifferenceEventDetailByInfo returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceEventDetailByInfo(arrList ...[]EventDetail) []EventDetail {
	if arrList == nil {
		return []EventDetail{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []EventDetail
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Info]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Info] = true
			}
		}
		return newList
	}

	var newList []EventDetail
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Info == v.Info {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Info]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Info] = true
			}
		}
	}
	return newList
}

// DifferenceEventDetailByInfoPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceEventDetailByInfoPtr(arrList ...[]*EventDetail) []*EventDetail {
	if arrList == nil {
		return []*EventDetail{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*EventDetail
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Info]
			if !ok {
				resultMap[arrList[0][i].Info] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*EventDetail
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Info == v.Info {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Info]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Info] = true
			}
		}
	}
	return newList
}

// SubsetEventDetailByInfo returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetEventDetailByInfo(list1, list2 []EventDetail) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Info]
		if !ok {
			found := false
			resultMap[list1[i].Info] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Info == list2[j].Info {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetEventDetailByInfoPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetEventDetailByInfoPtr(list1, list2 []*EventDetail) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Info]
		if !ok {
			found := false
			resultMap[list1[i].Info] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Info == list2[j].Info {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetEventDetailByInfo returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetEventDetailByInfo(list1, list2 []EventDetail) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Info]
		if !ok {
			found := false
			resultMap[list2[i].Info] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Info == list1[j].Info {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetEventDetailByInfoPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetEventDetailByInfoPtr(list1, list2 []*EventDetail) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Info]
		if !ok {
			found := false
			resultMap[list2[i].Info] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Info == list1[j].Info {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetEventDetailByInfo returns a set of the distinct elements of coll.
func SetEventDetailByInfo(list []EventDetail) []EventDetail {
	if list == nil || len(list) == 0 {
		return []EventDetail{}
	}

	resultMap := make(map[string]bool)
	newList := []EventDetail{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Info]
		if !ok {
			resultMap[list[i].Info] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetEventDetailByInfoPtr returns a set of the distinct elements of coll.
func SetEventDetailByInfoPtr(list []*EventDetail) []*EventDetail {
	if list == nil || len(list) == 0 {
		return []*EventDetail{}
	}

	resultMap := make(map[string]bool)
	newList := []*EventDetail{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Info]
		if !ok {
			resultMap[list[i].Info] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionEventDetailByURL return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionEventDetailByURL(arrList ...[]EventDetail) []EventDetail {
	resultMap := make(map[string]bool)
	var resultArr []EventDetail
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.URL]
			if !ok {
				resultMap[v.URL] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionEventDetailByURLPtr(arrList ...[]*EventDetail) []*EventDetail {
	resultMap := make(map[string]bool)
	var resultArr []*EventDetail
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.URL]
			if !ok {
				resultMap[v.URL] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionEventDetailByURL return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionEventDetailByURL(arrList ...[]EventDetail) []EventDetail {
	if arrList == nil {
		return []EventDetail{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []EventDetail
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].URL]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].URL] = true
			}
		}
		return newList
	}

	var newList []EventDetail
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].URL == v.URL {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].URL]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].URL] = true
			}
		}
	}
	return newList
}

// IntersectionEventDetailByURLPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionEventDetailByURLPtr(arrList ...[]*EventDetail) []*EventDetail {
	if arrList == nil {
		return []*EventDetail{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*EventDetail
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].URL]
			if !ok {
				resultMap[arrList[0][i].URL] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*EventDetail
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].URL == v.URL {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].URL]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].URL] = true
			}
		}
	}
	return newList
}

// DifferenceEventDetailByURL returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceEventDetailByURL(arrList ...[]EventDetail) []EventDetail {
	if arrList == nil {
		return []EventDetail{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []EventDetail
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].URL]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].URL] = true
			}
		}
		return newList
	}

	var newList []EventDetail
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].URL == v.URL {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].URL]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].URL] = true
			}
		}
	}
	return newList
}

// DifferenceEventDetailByURLPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceEventDetailByURLPtr(arrList ...[]*EventDetail) []*EventDetail {
	if arrList == nil {
		return []*EventDetail{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*EventDetail
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].URL]
			if !ok {
				resultMap[arrList[0][i].URL] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*EventDetail
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].URL == v.URL {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].URL]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].URL] = true
			}
		}
	}
	return newList
}

// SubsetEventDetailByURL returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetEventDetailByURL(list1, list2 []EventDetail) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].URL]
		if !ok {
			found := false
			resultMap[list1[i].URL] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].URL == list2[j].URL {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetEventDetailByURLPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetEventDetailByURLPtr(list1, list2 []*EventDetail) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].URL]
		if !ok {
			found := false
			resultMap[list1[i].URL] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].URL == list2[j].URL {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetEventDetailByURL returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetEventDetailByURL(list1, list2 []EventDetail) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].URL]
		if !ok {
			found := false
			resultMap[list2[i].URL] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].URL == list1[j].URL {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetEventDetailByURLPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetEventDetailByURLPtr(list1, list2 []*EventDetail) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].URL]
		if !ok {
			found := false
			resultMap[list2[i].URL] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].URL == list1[j].URL {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetEventDetailByURL returns a set of the distinct elements of coll.
func SetEventDetailByURL(list []EventDetail) []EventDetail {
	if list == nil || len(list) == 0 {
		return []EventDetail{}
	}

	resultMap := make(map[string]bool)
	newList := []EventDetail{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].URL]
		if !ok {
			resultMap[list[i].URL] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetEventDetailByURLPtr returns a set of the distinct elements of coll.
func SetEventDetailByURLPtr(list []*EventDetail) []*EventDetail {
	if list == nil || len(list) == 0 {
		return []*EventDetail{}
	}

	resultMap := make(map[string]bool)
	newList := []*EventDetail{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].URL]
		if !ok {
			resultMap[list[i].URL] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionEventDetailByType return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionEventDetailByType(arrList ...[]EventDetail) []EventDetail {
	resultMap := make(map[string]bool)
	var resultArr []EventDetail
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Type]
			if !ok {
				resultMap[v.Type] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionEventDetailByTypePtr(arrList ...[]*EventDetail) []*EventDetail {
	resultMap := make(map[string]bool)
	var resultArr []*EventDetail
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Type]
			if !ok {
				resultMap[v.Type] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionEventDetailByType return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionEventDetailByType(arrList ...[]EventDetail) []EventDetail {
	if arrList == nil {
		return []EventDetail{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []EventDetail
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Type]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Type] = true
			}
		}
		return newList
	}

	var newList []EventDetail
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Type == v.Type {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Type]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Type] = true
			}
		}
	}
	return newList
}

// IntersectionEventDetailByTypePtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionEventDetailByTypePtr(arrList ...[]*EventDetail) []*EventDetail {
	if arrList == nil {
		return []*EventDetail{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*EventDetail
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Type]
			if !ok {
				resultMap[arrList[0][i].Type] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*EventDetail
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Type == v.Type {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Type]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Type] = true
			}
		}
	}
	return newList
}

// DifferenceEventDetailByType returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceEventDetailByType(arrList ...[]EventDetail) []EventDetail {
	if arrList == nil {
		return []EventDetail{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []EventDetail
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Type]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Type] = true
			}
		}
		return newList
	}

	var newList []EventDetail
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Type == v.Type {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Type]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Type] = true
			}
		}
	}
	return newList
}

// DifferenceEventDetailByTypePtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceEventDetailByTypePtr(arrList ...[]*EventDetail) []*EventDetail {
	if arrList == nil {
		return []*EventDetail{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*EventDetail
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Type]
			if !ok {
				resultMap[arrList[0][i].Type] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*EventDetail
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Type == v.Type {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Type]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Type] = true
			}
		}
	}
	return newList
}

// SubsetEventDetailByType returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetEventDetailByType(list1, list2 []EventDetail) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Type]
		if !ok {
			found := false
			resultMap[list1[i].Type] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Type == list2[j].Type {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetEventDetailByTypePtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetEventDetailByTypePtr(list1, list2 []*EventDetail) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Type]
		if !ok {
			found := false
			resultMap[list1[i].Type] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Type == list2[j].Type {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetEventDetailByType returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetEventDetailByType(list1, list2 []EventDetail) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Type]
		if !ok {
			found := false
			resultMap[list2[i].Type] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Type == list1[j].Type {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetEventDetailByTypePtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetEventDetailByTypePtr(list1, list2 []*EventDetail) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Type]
		if !ok {
			found := false
			resultMap[list2[i].Type] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Type == list1[j].Type {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetEventDetailByType returns a set of the distinct elements of coll.
func SetEventDetailByType(list []EventDetail) []EventDetail {
	if list == nil || len(list) == 0 {
		return []EventDetail{}
	}

	resultMap := make(map[string]bool)
	newList := []EventDetail{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Type]
		if !ok {
			resultMap[list[i].Type] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetEventDetailByTypePtr returns a set of the distinct elements of coll.
func SetEventDetailByTypePtr(list []*EventDetail) []*EventDetail {
	if list == nil || len(list) == 0 {
		return []*EventDetail{}
	}

	resultMap := make(map[string]bool)
	newList := []*EventDetail{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Type]
		if !ok {
			resultMap[list[i].Type] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionEventDetailByCreationDate return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionEventDetailByCreationDate(arrList ...[]EventDetail) []EventDetail {
	resultMap := make(map[time.Time]bool)
	var resultArr []EventDetail
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.CreationDate]
			if !ok {
				resultMap[v.CreationDate] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionEventDetailByCreationDatePtr(arrList ...[]*EventDetail) []*EventDetail {
	resultMap := make(map[time.Time]bool)
	var resultArr []*EventDetail
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.CreationDate]
			if !ok {
				resultMap[v.CreationDate] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionEventDetailByCreationDate return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionEventDetailByCreationDate(arrList ...[]EventDetail) []EventDetail {
	if arrList == nil {
		return []EventDetail{}
	}

	resultMap := make(map[time.Time]bool)
	if len(arrList) == 1 {
		var newList []EventDetail
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].CreationDate]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].CreationDate] = true
			}
		}
		return newList
	}

	var newList []EventDetail
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].CreationDate == v.CreationDate {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].CreationDate]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].CreationDate] = true
			}
		}
	}
	return newList
}

// IntersectionEventDetailByCreationDatePtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionEventDetailByCreationDatePtr(arrList ...[]*EventDetail) []*EventDetail {
	if arrList == nil {
		return []*EventDetail{}
	}

	resultMap := make(map[time.Time]bool)
	if len(arrList) == 1 {
		var newList []*EventDetail
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].CreationDate]
			if !ok {
				resultMap[arrList[0][i].CreationDate] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*EventDetail
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].CreationDate == v.CreationDate {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].CreationDate]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].CreationDate] = true
			}
		}
	}
	return newList
}

// DifferenceEventDetailByCreationDate returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceEventDetailByCreationDate(arrList ...[]EventDetail) []EventDetail {
	if arrList == nil {
		return []EventDetail{}
	}

	resultMap := make(map[time.Time]bool)
	if len(arrList) == 1 {
		var newList []EventDetail
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].CreationDate]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].CreationDate] = true
			}
		}
		return newList
	}

	var newList []EventDetail
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].CreationDate == v.CreationDate {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].CreationDate]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].CreationDate] = true
			}
		}
	}
	return newList
}

// DifferenceEventDetailByCreationDatePtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceEventDetailByCreationDatePtr(arrList ...[]*EventDetail) []*EventDetail {
	if arrList == nil {
		return []*EventDetail{}
	}

	resultMap := make(map[time.Time]bool)
	if len(arrList) == 1 {
		var newList []*EventDetail
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].CreationDate]
			if !ok {
				resultMap[arrList[0][i].CreationDate] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*EventDetail
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].CreationDate == v.CreationDate {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].CreationDate]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].CreationDate] = true
			}
		}
	}
	return newList
}

// SubsetEventDetailByCreationDate returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetEventDetailByCreationDate(list1, list2 []EventDetail) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[time.Time]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].CreationDate]
		if !ok {
			found := false
			resultMap[list1[i].CreationDate] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].CreationDate == list2[j].CreationDate {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetEventDetailByCreationDatePtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetEventDetailByCreationDatePtr(list1, list2 []*EventDetail) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[time.Time]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].CreationDate]
		if !ok {
			found := false
			resultMap[list1[i].CreationDate] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].CreationDate == list2[j].CreationDate {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetEventDetailByCreationDate returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetEventDetailByCreationDate(list1, list2 []EventDetail) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[time.Time]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].CreationDate]
		if !ok {
			found := false
			resultMap[list2[i].CreationDate] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].CreationDate == list1[j].CreationDate {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetEventDetailByCreationDatePtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetEventDetailByCreationDatePtr(list1, list2 []*EventDetail) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[time.Time]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].CreationDate]
		if !ok {
			found := false
			resultMap[list2[i].CreationDate] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].CreationDate == list1[j].CreationDate {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetEventDetailByCreationDate returns a set of the distinct elements of coll.
func SetEventDetailByCreationDate(list []EventDetail) []EventDetail {
	if list == nil || len(list) == 0 {
		return []EventDetail{}
	}

	resultMap := make(map[time.Time]bool)
	newList := []EventDetail{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].CreationDate]
		if !ok {
			resultMap[list[i].CreationDate] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetEventDetailByCreationDatePtr returns a set of the distinct elements of coll.
func SetEventDetailByCreationDatePtr(list []*EventDetail) []*EventDetail {
	if list == nil || len(list) == 0 {
		return []*EventDetail{}
	}

	resultMap := make(map[time.Time]bool)
	newList := []*EventDetail{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].CreationDate]
		if !ok {
			resultMap[list[i].CreationDate] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}