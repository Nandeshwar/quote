// Code generated by 'gofp'. DO NOT EDIT.
package event
import "sync" 

func MapEventDetail(f func(EventDetail) EventDetail, list []EventDetail) []EventDetail {
	if f == nil {
		return []EventDetail{}
	}
	newList := make([]EventDetail, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

func FilterEventDetail(f func(EventDetail) bool, list []EventDetail) []EventDetail {
	if f == nil {
		return []EventDetail{}
	}
	var newList []EventDetail
	for _, v := range list {
		if f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

func FilterPtrEventDetail(f func(*EventDetail) bool, list []*EventDetail) []*EventDetail {
	if f == nil {
		return []*EventDetail{}
	}
	var newList []*EventDetail
	for _, v := range list {
		if f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

func RemoveEventDetail(f func(EventDetail) bool, list []EventDetail) []EventDetail {
	if f == nil {
		return []EventDetail{}
	}
	var newList []EventDetail
	for _, v := range list {
		if !f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

func SomeEventDetail(f func(EventDetail) bool, list []EventDetail) bool {
	if f == nil {
		return false
	}
	for _, v := range list {
		if f(v) {
			return true
		}
	}
	return false
}

func EveryEventDetail(f func(EventDetail) bool, list []EventDetail) bool {
	if f == nil || len(list) == 0 {
		return false
	}
	for _, v := range list {
		if !f(v) {
			return false
		}
	}
	return true
}

func DropWhileEventDetail(f func(EventDetail) bool, list []EventDetail) []EventDetail {
	if f == nil {
		return []EventDetail{}
	}
	var newList []EventDetail
	for i, v := range list {
		if !f(v) {
			listLen := len(list)
			newList = make([]EventDetail, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList
		}
	}
	return newList
}

func TakeWhileEventDetail(f func(EventDetail) bool, list []EventDetail) []EventDetail {
	if f == nil {
		return []EventDetail{}
	}
	var newList []EventDetail
	for _, v := range list {
		if !f(v) {
			return newList
		}
		newList = append(newList, v)
	}
	return newList
}

func PMapEventDetail(f func(EventDetail) EventDetail, list []EventDetail) []EventDetail {
	if f == nil {
		return []EventDetail{}
	}

	ch := make(chan map[int]EventDetail)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]EventDetail, i int, v EventDetail) {
			defer wg.Done()
			ch <- map[int]EventDetail{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]EventDetail, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

func FilterMapEventDetail(fFilter func(EventDetail) bool, fMap func(EventDetail) EventDetail, list []EventDetail) []EventDetail {
	if fFilter == nil || fMap == nil {
		return []EventDetail{}
	}
	var newList []EventDetail
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

func RestEventDetail(l []EventDetail) []EventDetail {
	if l == nil {
		return []EventDetail{}
	}

	len := len(l)
	if len == 0 || len == 1 {
		return []EventDetail{}
	}

	newList := make([]EventDetail, len-1)

	for i, v := range l[1:] {
		newList[i] = v
	}

	return newList
}

func ReduceEventDetail(f func(EventDetail, EventDetail) EventDetail, list []EventDetail, initializer ...EventDetail) EventDetail {
	var init EventDetail 
	lenList := len(list)

	if initializer != nil {
		init = initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0]
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}
	
	if lenList == 0 {
		return init
	}
	r := f(init, list[0])
	return ReduceEventDetail(f, list[1:], r)
}

// DropLastEventDetail drops last item from the list and returns new list.
// Returns empty list if there is only one item in the list or list empty
func DropLastEventDetail(list []EventDetail) []EventDetail {
	listLen := len(list)

	if list == nil || listLen == 0 || listLen == 1 {
		return []EventDetail{}
	}

	newList := make([]EventDetail, listLen-1)

	for i := 0; i < listLen-1; i++ {
		newList[i] = list[i]
	}
	return newList
}



// MergeEventDetail takes two inputs: map[EventDetail]EventDetail and map[EventDetail]EventDetail and merge two maps and returns a new map[EventDetail]EventDetail.
func MergeEventDetail(map1, map2 map[EventDetail]EventDetail) map[EventDetail]EventDetail {
	if map1 == nil && map2 == nil {
		return map[EventDetail]EventDetail{}
	}

	newMap := make(map[EventDetail]EventDetail)

	if map1 == nil {
		for k, v := range map2 {
			newMap[k] = v
		}
		return newMap
	}

	if map2 == nil {
		for k, v := range map1 {
			newMap[k] = v
		}
		return newMap
	}

	for k, v := range map1 {
		newMap[k] = v
	}

	for k, v := range map2 {
		newMap[k] = v
	}

	return newMap
}

// ZipEventDetail takes two inputs: first list of type: []EventDetail, second list of type: []EventDetail.
// Then it merges two list and returns a new map of type: map[EventDetail]EventDetail
func ZipEventDetail(list1 []EventDetail, list2 []EventDetail) map[EventDetail]EventDetail {
	newMap := make(map[EventDetail]EventDetail)

	len1 := len(list1)
	len2 := len(list2)

	if len1 == 0 || len2 == 0 {
		return newMap
	}

	minLen := len1
	if len2 < minLen {
		minLen = len2
	}

	for i := 0; i < minLen; i++ {
		newMap[list1[i]] = list2[i]
	}

	return newMap
}
